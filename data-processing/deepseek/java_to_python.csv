example_id,start_language,target_language,source_code,reference_code,translated_code,inference_time,bleu_1,bleu_2,bleu_4,keyword_match,codebleu
2048,Java,Python,"import java . io . * ; class GFG { static int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) System . out . println ( "" Wrong ▁ input "" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; } public static void main ( String [ ] args ) { System . out . println ( calcAngle ( 9 , 60 ) + "" ▁ degree "" ) ; System . out . println ( calcAngle ( 3 , 30 ) + "" ▁ degree "" ) ; } }","def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( ' Wrong ▁ input ' ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE h += 1 ; NEW_LINE if ( h > 12 ) : NEW_LINE INDENT h = h - 12 ; NEW_LINE DEDENT DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT h = 9 NEW_LINE m = 60 NEW_LINE print ( ' Angle ▁ ' , calcAngle ( h , m ) ) NEW_LINE","import sys class GFG: @staticmethod def calcAngle(h, m): if h < 0 or m < 0 or h > 12 or m > 60: print(""Wrong input"") if h == 12: h = 0 if m == 60: m = 0; h += 1 if h > 12: h -= 12 hour_angle = int(0.5 * (h * 60 + m)) minute_angle = int(6 * m) angle = abs(hour_angle - minute_angle) angle = min(360 - angle, angle) return angle def main(args): print(str(GFG.calcAngle(9, 60)) + "" degree"") print(str(GFG.calcAngle(3, 30)) + "" degree"") ",7.306861877441406,0.7038593633266915,0.5552981742762123,0.38491345330496696,0.8,0.5094394173134769
2200,Java,Python,"class Main { static int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = arr . length ; System . out . println ( "" The ▁ maximum ▁ element ▁ is ▁ "" + findMaximum ( arr , 0 , n - 1 ) ) ; } }","def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] ; NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 50 , 10 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ maximum ▁ element ▁ is ▁ % d "" % findMaximum ( arr , 0 , n - 1 ) ) NEW_LINE","class Main: @staticmethod def find_maximum(arr, low, high): if low == high: return arr[low] if (high == low + 1) and arr[low] >= arr[high]: return arr[low] if (high == low + 1) and arr[low] < arr[high]: return arr[high] mid = (low + high) // 2 if (arr[mid] > arr[mid+1]) and (arr[mid] > arr[mid-1]): return arr[mid] elif (arr[mid] > arr[mid+1]) and (arr[mid] < arr[mid-1]): return Main.find_maximum(arr, low, mid - 1) else: return Main.find_maximum(arr, mid + 1, high) if __name__ == ""__main__"": arr = [1, 3, 50, 10, 9, 7, 6] n = len(arr) print(""The maximum element is"", Main.find_maximum(arr, 0, n-1)) ",8.713987112045288,0.7475835181702124,0.6563066015015012,0.531030555055575,0.8571428571428571,0.6288642456817596
9260,Java,Python,import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void main ( String [ ] args ) { double r = 7 ; System . out . println ( length_rope ( r ) ) ; } },PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE,"import math class GFG: PI = 3.14159265 @staticmethod def length_rope(r): return (2 * GFG.PI * r) + (6 * r) if __name__ == ""__main__"": gfg = GFG() r = 7 print(gfg.length_rope(r)) ",2.3957769870758057,0.5961538461538461,0.5071137980998227,0.30080485625323855,0.5714285714285715,0.38199197080583847
13513,Java,Python,"import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } public static void main ( String [ ] args ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( "" phi ( "" + n + "" ) ▁ = ▁ "" + phi ( n ) ) ; } }","def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def phi ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( gcd ( i , n ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT for n in range ( 1 , 11 ) : NEW_LINE INDENT print ( "" phi ( "" , n , "" ) ▁ = ▁ "" , phi ( n ) , sep = "" "" ) NEW_LINE DEDENT","def gcd(a, b): if a == 0: return b return gcd(b % a, a) def phi(n): result = 1 for i in range(2, n): if gcd(i, n) == 1: result += 1 return result for n in range(1, 11): print(""φ("" + str(n) + "") = "" + str(phi(n))) ",2.9374661445617676,0.6848747312795102,0.576585869495408,0.4271410384598846,1.0,0.5989987269219192
2000,Java,Python,"import java . io . * ; class GFG { static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }","def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT print ( pow ( 5 , 3 ) ) NEW_LINE","def pow(a, b): if b == 0: return 1 answer = a increment = a for i in range(1, b): for j in range(1, a): answer += increment increment = answer return answer print(pow(5, 3)) ",2.345254898071289,0.6962343500239326,0.6186204538410114,0.4756712609245324,1.0,0.6329698826471726
1682,Java,Python,"class EquilibriumIndex { int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { EquilibriumIndex equi = new EquilibriumIndex ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . length ; System . out . println ( equi . equilibrium ( arr , arr_size ) ) ; } }","def equilibrium ( arr ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if leftsum == rightsum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 7 , 1 , 5 , 2 , - 4 , 3 , 0 ] NEW_LINE print ( equilibrium ( arr ) ) NEW_LINE","class EquilibriumIndex: def equilibrium(self, arr , n): for i in range(n): leftsum = 0 rightsum = 0 for j in range(i): leftsum += arr[j] for j in range(i+1,n): rightsum += arr[j] if leftsum == rightsum: return i return -1 equi = EquilibriumIndex() arr=[-7, 1, 5, 2, -4, 3, 0] arr_size=len(arr) print(equi.equilibrium(arr, arr_size)) ",3.2699949741363525,0.6245517845008887,0.5311563081364361,0.3715432498853684,0.9090909090909091,0.5328075476470306
13511,Java,Python,"class GFG { static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } public static void main ( String args [ ] ) { int a = 3 , m = 11 ; System . out . println ( "" Modular ▁ multiplicative ▁ "" + "" inverse ▁ is ▁ "" + modInverse ( a , m ) ) ; } }","def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( "" Modular ▁ multiplicative ▁ inverse ▁ is "" , modInverse ( a , m ) ) NEW_LINE","class GFG: @staticmethod def mod_inverse(a, m): m0 = m y = 0 x = 1 if (m == 1) : return 0 while (a > 1) : q = a // m t = m m = a % m a = t t = y y = x - q * y x = t if (x < 0): x += m0 return x if __name__ == ""__main__"": a = 3 m = 11 print(""Modular multiplicative inverse is "", GFG.mod_inverse(a, m)) ",3.5084409713745117,0.7089458160610888,0.6045454540407869,0.4077537963055665,0.9090909090909091,0.5581549301411692
1994,Java,Python,"import java . io . * ; class GFG { public static int counter = 2 ; static boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } public static void main ( String [ ] args ) { int x = 5 ; if ( isLucky ( x ) ) System . out . println ( x + "" ▁ is ▁ a ▁ lucky ▁ no . "" ) ; else System . out . println ( x + "" ▁ is ▁ not ▁ a ▁ lucky ▁ no . "" ) ; } }","def isLucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_position = next_position - next_position / isLucky . counter NEW_LINE isLucky . counter = isLucky . counter + 1 NEW_LINE return isLucky ( next_position ) NEW_LINE DEDENT isLucky . counter = 2 NEW_LINE x = 5 NEW_LINE if isLucky ( x ) : NEW_LINE INDENT print x , "" is ▁ a ▁ Lucky ▁ number "" NEW_LINE DEDENT else : NEW_LINE INDENT print x , "" is ▁ not ▁ a ▁ Lucky ▁ number "" NEW_LINE DEDENT","class GFG: counter = 2 @staticmethod def is_lucky(n): next_position = n if GFG.counter > n: return True if n % GFG.counter == 0: return False next_position -= next<｜begin▁of▁sentence｜>next_position / GFG.counter GFG.counter += 1 return GFG.is_lucky(next_position) @staticmethod def main(): x = 5 if GFG.is_lucky(x): print(f""{x} is a lucky no."") else: print(f""{x} is not a lucky no."") GFG.main() ",3.7445268630981445,0.4300187496505485,0.28111205072806633,0.10575185001261524,0.8,0.31402629500883067
1824,Java,Python,"import java . util . * ; import java . lang . * ; import java . io . * ; class ActivitySelection { public static void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; System . out . print ( "" Following ▁ activities ▁ are ▁ selected ▁ : ▁ n "" ) ; i = 0 ; System . out . print ( i + "" ▁ "" ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { System . out . print ( j + "" ▁ "" ) ; i = j ; } } } public static void main ( String [ ] args ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = s . length ; printMaxActivities ( s , f , n ) ; } }","def printMaxActivities ( s , f ) : NEW_LINE INDENT n = len ( f ) NEW_LINE print "" The ▁ following ▁ activities ▁ are ▁ selected "" NEW_LINE i = 0 NEW_LINE print i , NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT if s [ j ] >= f [ i ] : NEW_LINE INDENT print j , NEW_LINE i = j NEW_LINE DEDENT DEDENT DEDENT s = [ 1 , 3 , 0 , 5 , 8 , 5 ] NEW_LINE f = [ 2 , 4 , 6 , 7 , 9 , 9 ] NEW_LINE printMaxActivities ( s , f ) NEW_LINE","def print_max_activities(s, f, n): i = 0 j = 1 print(""Following activities are selected : "", end='') print(i ,end=' ') while j < n: if s[j] >= f[i]: print(j ,end=' ') i = j j += 1 def main(): s = [1, 3, 0, 5, 8, 5] f = [2, 4, 6, 7, 9, 9] n = len(s) print_max_activities(s, f, n) if __name<｜begin▁of▁sentence｜>__ == ""__main__"": main() ",4.948103904724121,0.6259541984732825,0.5238862862005977,0.40508610697736946,0.5714285714285715,0.45498884631273007
13031,Java,Python,"public class Power_3 { static boolean check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; } public static void main ( String args [ ] ) { int n = 9 ; if ( check ( n ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT n = 9 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT","class Power_3: @staticmethod def check(n): if n <= 0: return False return 1162261467 % n == 0 def main(): n = 9 print(""Yes"") if Power_3.check(n) else print(""No"") Power_3().main() ",2.417926788330078,0.5964912280701754,0.47295265146345866,0.3030569342881791,0.8,0.45213985400172535
2001,Java,Python,"import java . io . * ; class GFG { static int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } static int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }","def multiply ( x , y ) : NEW_LINE INDENT if ( y ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def pow ( a , b ) : NEW_LINE INDENT if ( b ) : NEW_LINE INDENT return multiply ( a , pow ( a , b - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT print ( pow ( 5 , 3 ) ) ; NEW_LINE","def multiply(x, y): if y > 0: return x + multiply(x, y - 1) else: return 0 def pow(a, b): if b > 0: return multiply(a, pow(a, b - 1)) else: return 1 print(pow(5, 3)) ",2.0135838985443115,0.6054392251305385,0.5282241357953237,0.43464073379537443,1.0,0.6042485136567621
1705,Java,Python,"class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( "" The ▁ two ▁ reppeated ▁ elements ▁ are ▁ : "" ) ; System . out . println ( x + "" ▁ "" + y ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }","def printRepeating ( arr , size ) : NEW_LINE INDENT xor = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor ^= i NEW_LINE DEDENT set_bit_no = xor & ~ ( xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( "" The ▁ two ▁ repeating "" , "" elements ▁ are "" , y , x ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE","class RepeatElement: def printRepeating(self, arr, size): xor = arr[0] set_bit_no = 0 n = size - 2 x, y = 0, 0 for i in range(1, size): xor ^= arr[i] for i in range(1, n+1): xor ^= i set_bit_no = (xor & -xor) for i in range(0, size): if ((arr[i] & set_bit_no) != 0): x = x ^ arr[i] else: y = y ^ arr[i] for i in range(1, n+1): if((i & set_bit_no) !=0): x = x ^ i else: y = y ^ i print(""The two repeated elements are : "") print(x,"" "", y) if __name__ == ""__main__"": repeat = RepeatElement() arr= [4,2,4,5,2,3,1] arr_size = len(arr) repeat.printRepeating(arr, arr_size) ",8.396210193634033,0.686217389375461,0.5836780014680397,0.4213765972119319,0.9090909090909091,0.5676908907756251
6659,Java,Python,"class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + "" ▁ "" ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } public static void main ( String arg [ ] ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; printknapSack ( W , wt , val , n ) ; } }","def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE","def max_(a, b): return a if (a > b) else b def printknapSack(W, wt, val, n): i, w = 0, 0 K = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(n+1): for w in range(W+1): if i == 0 or w == 0: K[i][w] = 0 elif wt[i-1] <= w: K[i][w] = max_(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] res = K[n][W] print(res) w = W for i in range(n, 0, -1): if res <= 0: break if res == K[i - 1][w]: continue else: print(wt[i - 1]) res = res - val[i - 1] w = w - wt[i - 1] val = [60, 100, 120] wt = [10, 20, 30] W = 50 n = len(val) printknapSack(W, wt, val, n) ",11.746031284332275,0.7470711847349361,0.6788940301872225,0.5561636275056159,0.9333333333333333,0.669314539253931
2095,Java,Python,"class GFG { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void main ( String arg [ ] ) { int n = 7 ; System . out . print ( "" The ▁ number ▁ after ▁ unsetting ▁ "" + "" the ▁ rightmost ▁ set ▁ bit ▁ "" + fun ( n ) ) ; } }","def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( "" The ▁ number ▁ after ▁ unsetting ▁ the ▁ rightmost ▁ set ▁ bit "" , fun ( n ) ) NEW_LINE","class GFG: @staticmethod def fun(n): return n & (n - 1) if __name__ == ""__main__"": n = 7 print(""The number after unsetting the rightmost set bit is"", GFG.fun(n)) ",1.8405790328979492,0.7083333333333334,0.5490158829362881,0.384434789863887,0.5714285714285715,0.4405329243332924
1861,Java,Python,"class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }","def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print knapSack ( W , wt , val , n ) NEW_LINE","def max(a, b): return a if a > b else b def knapSack(W, wt, val, n): if W == 0 or n == 0: return 0 if wt[n - 1] > W: return knapSack(W, wt, val, n - 1) else: return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), knapSack(W, wt, val, n - 1)) if __name__ == ""__main__"": val = [60, 100, 120] wt = [10, 20, 30] W = 50 n = len(val) print(knapSack(W, wt, val, n)) ",5.877748966217041,0.8506493506493507,0.7926268753653772,0.6948045831408701,1.0,0.786363208198609
1843,Java,Python,"public class GFG { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( minCost ( cost , 2 , 2 ) ) ; } }","R = 3 NEW_LINE C = 3 NEW_LINE import sys NEW_LINE def min ( x , y , z ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x if ( x < z ) else z NEW_LINE DEDENT else : NEW_LINE INDENT return y if ( y < z ) else z NEW_LINE DEDENT DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE","class GFG: @staticmethod def min_(x, y, z): if x < y: return x if x < z else z else: return y if y < z else z @staticmethod def minCost(cost, m , n ): if m < 0 or n < 0 : return float('inf') # equals to Integer.MAX_VALUE in Java elif m == 0 and n == 0: return cost[m][n] # equals to cost[m][n] in Java else: return cost[m][n] + GFG.min_(GFG.minCost(cost, m-1 ,n-1), GFG.minCost(cost, m-1, n), GFG.minCost(cost, m, n-1)) # equals to ( cost[m][n] + min( minCost() ) in Java # main function if __name__ == ""__main__"": cost = [[1,2,3], [4,8,2], [1,5,3]] #equals to int cost[][]={{1,2,3},{4,8,2},{1,5,3}} in Java print(GFG.minCost(cost, 2 , 2)) # equals to System.out.print() in Java ",7.768912076950073,0.6157205240174672,0.4902520236122857,0.3269817998070712,0.823529411764706,0.4759460833943616
1867,Java,Python,"class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = "" GEEKSFORGEEKS "" ; int n = seq . length ( ) ; System . out . printf ( "" The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d "" , lps ( seq . toCharArray ( ) , 0 , n - 1 ) ) ; } }","def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT seq = "" GEEKSFORGEEKS "" NEW_LINE n = len ( seq ) NEW_LINE print ( "" The ▁ length ▁ of ▁ the ▁ LPS ▁ is "" , lps ( seq , 0 , n - 1 ) ) NEW_LINE DEDENT","class GFG: @staticmethod def max(x, y): return x if x > y else y @staticmethod def lps(seq, i, j): if i == j: return 1 if seq[i] == seq[j] and i + 1 == j: return 2 if seq[i] == seq[j]: return GFG.lps(seq, i+1, j-1) + 2 return GFG.max(GFG.lps(seq, i, j-1), GFG.lps(seq, i+1, j)) def main(args): seq = ""GEEKSFORGEEKS"" n = len(seq) print(""The length of the LPS is "", GFG.lps(seq, 0, n-1)) ",7.443538188934326,0.5889281086251681,0.47852426028806855,0.33784241814288746,0.8333333333333333,0.4864896927000212
1949,Java,Python,"public class NaiveSearch { public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( "" Pattern ▁ found ▁ at ▁ index ▁ "" + i ) ; } } public static void main ( String [ ] args ) { String txt = "" AABAACAADAABAAABAA "" ; String pat = "" AABA "" ; search ( txt , pat ) ; } }","def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( "" Pattern ▁ found ▁ at ▁ index ▁ "" , i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT txt = "" AABAACAADAABAAABAA "" NEW_LINE pat = "" AABA "" NEW_LINE search ( pat , txt ) NEW_LINE DEDENT","class NaiveSearch: @staticmethod def search(txt, pat): M = len(pat) N = len(txt) for i in range(N - M + 1): j = 0 while j < M and txt[i + j] == pat[j]: j += 1 if j == M: print(""Pattern found at index"", i) @staticmethod def main(): txt = ""AABAACAADAABAAABAA"" pat = ""AABA"" NaiveSearch.search(txt, pat) NaiveSearch.main() ",5.773876190185547,0.6130691031079077,0.4754356678259135,0.3073818174034554,0.8333333333333333,0.4651672721824187
13418,Java,Python,"import java . io . * ; import static java . lang . Math . * ; class Quadratic { static void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( "" Invalid "" ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( ""Roots are real and different NEW_LINE""); System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + ""NEW_LINE"" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { System . out . println ( ""Roots are real and same NEW_LINE""); System . out . println ( - ( double ) b / ( 2 * a ) + ""NEW_LINE"" + - ( double ) b / ( 2 * a ) ) ; } { System . out . println ( ""Roots are complex NEW_LINE""); System . out . println ( - ( double ) b / ( 2 * a ) + "" ▁ + ▁ i "" + sqrt_val + ""NEW_LINE"" + - ( double ) b / ( 2 * a ) + "" ▁ - ▁ i "" + sqrt_val ) ; } } public static void main ( String args [ ] ) { int a = 1 , b = - 7 , c = 12 ; findRoots ( a , b , c ) ; } }","import math NEW_LINE def findRoots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( "" Invalid "" ) NEW_LINE return - 1 NEW_LINE DEDENT d = b * b - 4 * a * c NEW_LINE sqrt_val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( "" Roots ▁ are ▁ real ▁ and ▁ different ▁ "" ) NEW_LINE print ( ( - b + sqrt_val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sqrt_val ) / ( 2 * a ) ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( "" Roots ▁ are ▁ real ▁ and ▁ same "" ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE print ( "" Roots ▁ are ▁ complex "" ) NEW_LINE print ( - b / ( 2 * a ) , "" ▁ + ▁ i "" , sqrt_val ) NEW_LINE print ( - b / ( 2 * a ) , "" ▁ - ▁ i "" , sqrt_val ) NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = - 7 NEW_LINE c = 12 NEW_LINE findRoots ( a , b , c ) NEW_LINE","import math from math import sqrt class Quadratic: @staticmethod def find_roots(a, b, c): if a == 0: print(""Invalid"") return d = b * b - 4 * a * c sqrt_val = sqrt(abs(d)) if d > 0: print(""Roots are real and different\n"", (-b + sqrt_val) / (2*a), ""\n"",(-b - sqrt_val) / (2*a)) elif d == 0: print(""Roots are real and same\n"", -b / (2*a), ""\n"",- b / (2*a)) else: print(""Roots are complex\n"", -b / (2*a), "" + i "", sqrt_val, ""\n"",-b / (2*a), "" - i "", sqrt_val) if __name__ == '__main__': a = 1 b = -7 c = 12 Quadratic.find_roots(a, b, c) ",8.55956768989563,0.6570390764911839,0.5555778731647618,0.4235703582029087,0.8,0.5364992507420361
1687,Java,Python,"class Main { static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( "" Ceiling ▁ of ▁ "" + x + "" ▁ doesn ' t ▁ exist ▁ in ▁ array "" ) ; else System . out . println ( "" ceiling ▁ of ▁ "" + x + "" ▁ is ▁ "" + arr [ index ] ) ; } }","def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( "" Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ "" % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" ceiling ▁ of ▁ % d ▁ is ▁ % d "" % ( x , arr [ index ] ) ) NEW_LINE DEDENT","class Main: @staticmethod def ceil_search(arr, low, high, x): i = 0 if x <= arr[low]: return low for i in range(low, high): if arr[i] == x: return i elif arr[i] < x and arr[i + 1] >= x: return i + 1 return -1 if __name<｜begin▁of▁sentence｜>__ = '__main__': arr = [1, 2, 8, 10, 10, 12, 19] n = len(arr) x = 3 index = Main.ceil_search(arr, 0, n - 1, x) if index == -1: print(""Ceiling of"",x,""doesn't exist in array"") else: print(""ceiling of"",x,""is"", arr[index]) ",5.542886018753052,0.6674199637138536,0.5790248293234262,0.4577817017949808,0.888888888888889,0.5871138579231532
8588,Java,Python,"import java . io . * ; class GFG { static boolean isPalRec ( String str , int s , int e ) { if ( s == e ) return true ; if ( ( str . charAt ( s ) ) != ( str . charAt ( e ) ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } static boolean isPalindrome ( String str ) { int n = str . length ( ) ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } public static void main ( String args [ ] ) { String str = "" geeg "" ; if ( isPalindrome ( str ) ) System . out . println ( "" Yes "" ) ; else System . out . println ( "" No "" ) ; } }","def isPalRec ( st , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( st [ s ] != st [ e ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s < e + 1 ) : NEW_LINE INDENT return isPalRec ( st , s + 1 , e - 1 ) ; NEW_LINE DEDENT return True NEW_LINE DEDENT def isPalindrome ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPalRec ( st , 0 , n - 1 ) ; NEW_LINE DEDENT st = "" geeg "" NEW_LINE if ( isPalindrome ( st ) ) : NEW_LINE INDENT print "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" No "" NEW_LINE DEDENT","class GFG: @staticmethod def isPalRec(strr, s, e): if s == e: return True if (strr[s] != strr[e]): return False if s < e + 1: return GFG.isPalRec(strr, s+1, e-1) return True @staticmethod def isPalindrome(strr): n = len(strr) if n == 0: return True return GFG.isPalRec(strr, 0, n - 1) if __name__ == ""__main__"": strr = ""geeg"" if (GFG.isPalindrome(strr)): print(""Yes"") else: print(""No"") ",6.81939697265625,0.5994512267294905,0.4347782282947877,0.23490384016213897,0.923076923076923,0.44135576503657414
7323,Java,Python,"public class Main { public final static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i , j ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat . charAt ( i ) ) % q ; t = ( d * t + txt . charAt ( i ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; } if ( j == M ) System . out . println ( "" Pattern ▁ found ▁ at ▁ index ▁ "" + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt . charAt ( i ) * h ) + txt . charAt ( i + M ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void main ( String [ ] args ) { String txt = "" GEEKS ▁ FOR ▁ GEEKS "" ; String pat = "" GEEK "" ; int q = 101 ; search ( pat , txt , q ) ; } }","d = 256 NEW_LINE def search ( pat , txt , q ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE h = 1 NEW_LINE for i in xrange ( M - 1 ) : NEW_LINE INDENT h = ( h * d ) % q NEW_LINE DEDENT for i in xrange ( M ) : NEW_LINE INDENT p = ( d * p + ord ( pat [ i ] ) ) % q NEW_LINE t = ( d * t + ord ( txt [ i ] ) ) % q NEW_LINE DEDENT for i in xrange ( N - M + 1 ) : NEW_LINE INDENT if p == t : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT else : j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print "" Pattern ▁ found ▁ at ▁ index ▁ "" + str ( i ) NEW_LINE DEDENT DEDENT if i < N - M : NEW_LINE INDENT t = ( d * ( t - ord ( txt [ i ] ) * h ) + ord ( txt [ i + M ] ) ) % q NEW_LINE if t < 0 : NEW_LINE INDENT t = t + q NEW_LINE DEDENT DEDENT DEDENT DEDENT txt = "" GEEKS ▁ FOR ▁ GEEKS "" NEW_LINE pat = "" GEEK "" NEW_LINE q = 101 NEW_LINE search ( pat , txt , q ) NEW_LINE","class Main: d = 256 @staticmethod def search(pat, txt, q): M = len(pat) N = len(txt) i = j = 0 h = 1 for i in range(M - 1): h = (h * Main.d) % q p = t = 0 for i in range(M): p = (Main.d * p + ord(pat[i])) % q t = (Main.d * t + ord(txt[i])) % q for i in range(N - M + 1): if p == t: for j in range(M): if txt[i + j] != pat[j]: break if j == M - 1: print(""Pattern found at index"", i) if i < N - M: t = (Main.d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q if t < 0: t += q @staticmethod def main(args): txt = ""GEEKS FOR GEEKS"" pat = ""GEEK"" q = 101 Main.search(pat, txt, q) if __name__ == '__main__': Main.main(None) ",11.175952196121216,0.7422086443684396,0.6536607619906496,0.5040959177254174,0.7272727272727272,0.5710489605896103
1944,Java,Python,"import java . util . Arrays ; class GFG { static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( "" Count ▁ for ▁ "" + n + "" ▁ is ▁ "" + count ( n ) ) ; n = 13 ; System . out . println ( "" Count ▁ for ▁ "" + n + "" ▁ is ▁ "" + count ( n ) ) ; } }","def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE","def count(n): table = [0]*(n + 1) table[0] = 1 for i in range(3, n+1): table[i] += table[i - 3] for i in range(5, n+1): table[i] += table[i - 5] for i in range(10, n+1): table[i] += table[i - 10] return table[n] print(""Count for"", 20, ""is"", count(20)) print(""Count for"", 13, ""is"", count(13)) ",6.8322412967681885,0.6544985677675315,0.5528802294529029,0.4164969943187095,1.0,0.5915478960230967
13895,Java,Python,import java . io . * ; class GFG { static int countBits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; } public static void main ( String [ ] args ) { int num = 65 ; System . out . println ( countBits ( num ) ) ; } },import math NEW_LINE def countBits ( number ) : NEW_LINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEW_LINE DEDENT num = 65 ; NEW_LINE print ( countBits ( num ) ) ; NEW_LINE,"import math class GFG: @staticmethod def count_bits(number): return int(math.log(number, 2) + 1) if __name__ == ""__main__"": num = 65 print(GFG.count_bits(num)) ",3.733734130859375,0.5240124963608563,0.42885664869494283,0.21219567496971048,0.7499999999999999,0.37353697247879725
1010,Java,Python,"import java . util . Arrays ; class GFG { static void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } static void printArray ( int arr [ ] ) { System . out . print ( Arrays . toString ( arr ) ) ; } public static void main ( String [ ] args ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . length ; int S [ ] = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S ) ; } }","def calculateSpan ( price , n , S ) : NEW_LINE INDENT S [ 0 ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT S [ i ] = 1 NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 ) and ( price [ i ] >= price [ j ] ) : NEW_LINE INDENT S [ i ] += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT price = [ 10 , 4 , 5 , 90 , 120 , 80 ] NEW_LINE n = len ( price ) NEW_LINE S = [ None ] * n NEW_LINE calculateSpan ( price , n , S ) NEW_LINE printArray ( S , n ) NEW_LINE","def calculate_span(price, n, S): S[0] = 1 for i in range(1, n): S[i] = 1 j = i - 1 while j >= 0 and price[i] >= price[j]: S[i] += 1 j -= 1 def print_array(arr): print(' '.join(map(str, arr))) price = [10, 4, 5, 90, 120, 80] n = len(price) S = [0]*n calculate_span(price, n, S) print_array(S) ",3.4457437992095947,0.6457847960657427,0.5523861114937121,0.42483270094176817,0.9090909090909091,0.5701101633865104
12814,Java,Python,"class GFG { static double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } public static void main ( String [ ] args ) { int x = 2 ; int n = 5 ; System . out . printf ( "" % .2f "" , sum ( x , n ) ) ; } }","def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT x = 2 NEW_LINE n = 5 NEW_LINE print ( round ( sum ( x , n ) , 2 ) ) NEW_LINE","class GFG: @staticmethod def sum(x, n): i = 1 total = 1.0 multi = x for _ in range(n): total += multi / i multi *= x i += 1 return total if __name__ == ""__main__"": x = 2 n = 5 print(""{:.2f}"".format(GFG.sum(x, n))) ",2.5715677738189697,0.68,0.507244810024999,0.2677578990607565,0.8,0.4274305293425295
7012,Java,Python,"import java . io . * ; class GFG { static int NUM_LINE = 2 ; static int NUM_STATION = 4 ; static int min ( int a , int b ) { return a < b ? a : b ; } static int carAssembly ( int a [ ] [ ] , int t [ ] [ ] , int e [ ] , int x [ ] ) { int T1 [ ] = new int [ NUM_STATION ] ; int T2 [ ] = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; System . out . println ( carAssembly ( a , t , e , x ) ) ; } }","def carAssembly ( a , t , e , x ) : NEW_LINE INDENT NUM_STATION = len ( a [ 0 ] ) NEW_LINE T1 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE T2 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE DEDENT T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE INDENT for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT a = [ [ 4 , 5 , 3 , 2 ] , [ 2 , 10 , 1 , 4 ] ] NEW_LINE t = [ [ 0 , 7 , 4 , 5 ] , [ 0 , 9 , 2 , 8 ] ] NEW_LINE e = [ 10 , 12 ] NEW_LINE x = [ 18 , 7 ] NEW_LINE print ( carAssembly ( a , t , e , x ) ) NEW_LINE","def min(a, b): return a if a < b else b def car_assembly(a, t, e, x): T1 = [0]*4 T2 = [0]*4 NUM_LINE = 2 NUM_STATION = 4 T1[0] = e[0] + a[0][0] T2[0] = e[1] + a[1][0] for i in range(1,NUM_STATION): T1[i] = min(T1[i-1]+a[0][i], T2[i-1]+t[1][i]+a[0][i]) T2[i] = min(T2[i-1]+a[1][i], T1[i-1]+t[0][i]+a[1][i]) return min(T1[NUM_STATION-1]+x[0], T2[NUM_STATION-1]+x[1]) def main(): a = [[4,5,3,2], [2,10,1,4]] t = [[0,7,4,5], [0,9,2,8]] e = [10,12] x = [18,7] print(car_assembly(a, t, e, x)) main() ",9.859141111373901,0.6568238229626614,0.5690636522713534,0.45099058485307875,0.8,0.5556934093971551
2066,Java,Python,"class GFG { static final int INT_SIZE = 32 ; static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = arr . length ; System . out . println ( "" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ "" + getSingle ( arr , n ) ) ; } }","INT_SIZE = 32 NEW_LINE def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( ( sm % 3 ) != 0 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ "" , getSingle ( arr , n ) ) NEW_LINE","class GFG: INT_SIZE = 32 @staticmethod def getSingle(arr, n): result = 0 x, sum = 0, 0 for i in range(INT_SIZE): sum=0 x = (1 << i) for j in range(n): if (( arr[j] & x )==0): sum += 1 if ((sum%3)!=0): result |= x return result def main(args): arr = [12, 1, 12, 3, 12, 1, 1, 2, 3, 2, 2, 3, 7] n = len(arr) print(""The element with single occurrence is "", GFG.getSingle(arr, n)) GFG.main(None) ",7.73347806930542,0.7254802100059767,0.6330904623722996,0.48553459657295295,0.8750000000000001,0.6023742176010671
1584,Java,Python,"import java . util . * ; import java . io . * ; class GFG { static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = arr . length ; System . out . print ( "" Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ "" + minJumps ( arr , 0 , n - 1 ) ) ; } }","def minJumps ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( i < l + arr [ l ] + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if ( jumps != float ( ' inf ' ) and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT arr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ' , ' end ▁ is ' , minJumps ( arr , 0 , n - 1 ) ) NEW_LINE","import sys def min_jumps(arr, l, h): if h == l: return 0 if arr[l] == 0: return sys.maxsize minn = sys.maxsize for i in range(l + 1, h+1): if i <= l + arr[l]: jumps = min_jumps(arr, i, h) if jumps != sys.maxsize and jumps + 1 < minn: minn = jumps + 1 return minn arr = [1, 3, 6, 3, 2, 3, 6, 8, 9, 5] n = len(arr) print(""Minimum number of jumps to reach end is"", min_jumps(arr, 0, n-1)) ",4.3692626953125,0.552197551690919,0.45350439871708187,0.3438261914337018,0.9333333333333333,0.5206783340035912
1531,Java,Python,"class GFG { public static void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { System . out . print ( "" ▁ Invalid ▁ Input ▁ "" ) ; return ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MIN_VALUE ) System . out . print ( "" There ▁ is ▁ no ▁ second ▁ largest "" + "" elementNEW_LINE""); else System . out . print ( "" The ▁ second ▁ largest ▁ element "" + "" ▁ is ▁ "" + second ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . length ; print2largest ( arr , n ) ; } }","def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( "" ▁ Invalid ▁ Input ▁ "" ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( "" There ▁ is ▁ no ▁ second ▁ largest ▁ element "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ second ▁ largest ▁ element ▁ is "" , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE","class GFG: @staticmethod def print2largest(arr, arr_size): first, second = float('-inf'), float('-inf') if arr_size < 2: return ""Invalid Input"" for i in range(0, arr_size): if arr[i] > first: second = first first = arr[i] elif arr[i] > second and arr[i] != first: second = arr[i] if second == float('-inf'): return ""There is no second largest element"" else: return f""The second largest element is {second}"" def main(args): arr= [12, 35, 1, 10, 34, 1] n = len(arr) print(GFG.print2largest(arr, n)) if __name__ == ""__main__"": GFG().main() ",7.480710029602051,0.686874876829901,0.5258911021869732,0.37082748605247556,0.9473684210526316,0.5437897665525224
1015,Java,Python,"class Main { static void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + "" ▁ - - ▁ "" + next ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = arr . length ; printNGE ( arr , n ) ; } }","def printNGE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + "" ▁ - - ▁ "" + str ( next ) ) NEW_LINE DEDENT DEDENT arr = [ 11 , 13 , 21 , 3 ] NEW_LINE printNGE ( arr ) NEW_LINE","class Main: @staticmethod def printNGE(arr, n): next = -1 i = 0 while i < n: j = i + 1 while j < n: if arr[i] < arr[j]: next = arr[j] break j += 1 print(str(arr[i]) + "" -- "" + str(next)) i += 1 def main(args): arr = [11, 13, 21, 3] n = len(arr) Main.printNGE(arr, n) Main().main(None) ",5.442739009857178,0.6955444915397553,0.5686539591920505,0.4312471647188798,0.4444444444444445,0.43520634863654917
2174,Java,Python,"import java . io . * ; class NextGreatest { static void nextGreatest ( int arr [ ] ) { int size = arr . length ; int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = - 1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } static void printArray ( int arr [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; nextGreatest ( arr ) ; System . out . println ( "" The ▁ modified ▁ array : "" ) ; printArray ( arr ) ; } }","def nextGreatest ( arr ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE max_from_right = arr [ size - 1 ] NEW_LINE arr [ size - 1 ] = - 1 NEW_LINE for i in range ( size - 2 , - 1 , - 1 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = max_from_right NEW_LINE if max_from_right < temp : NEW_LINE INDENT max_from_right = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT arr = [ 16 , 17 , 4 , 3 , 5 , 2 ] NEW_LINE nextGreatest ( arr ) NEW_LINE print "" Modified ▁ array ▁ is "" NEW_LINE printArray ( arr ) NEW_LINE","def next_greatest(arr): size = len(arr) max_from_right = arr[size - 1] arr[size - 1] = -1 for i in range(size-2, -1, -1): temp = arr[i] arr[i] = max_from_right if max_from_right < temp: max_from_right = temp def printArray(arr): for i in range(len(arr)): print(arr[i], end="" "") # Test the function arr = [16, 17, 4, 3, 5, 2] next_greatest(arr) print(""The modified array :"") printArray(arr) ",5.453420877456665,0.6967180026224504,0.6096943849425491,0.4718238248500432,0.888888888888889,0.5969433440616969
11738,Java,Python,"import java . io . * ; class GFG { static double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . printf ( "" Sum ▁ is ▁ % f "" , sum ( n ) ) ; } }","def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( "" Sum ▁ is "" , round ( sum ( n ) , 6 ) ) NEW_LINE","def sum_series(n): s = 0.0 for i in range(1, n + 1): s = s + 1 / i return s if __name__ == ""__main__"": n = 5 print(""Sum ▁ is ▁ % f"" % sum_series(n)) ",2.0424578189849854,0.6197511271648526,0.5478387354658374,0.4085944374322166,0.9090909090909091,0.5587433789298243
1981,Java,Python,"class Main { static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } public static void main ( String [ ] args ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = ar1 . length ; int n2 = ar2 . length ; if ( n1 == n2 ) System . out . println ( "" Median ▁ is ▁ "" + getMedian ( ar1 , ar2 , n1 ) ) ; else System . out . println ( "" arrays ▁ are ▁ of ▁ unequal ▁ size "" ) ; } }","def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] <= ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT ar1 = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE ar2 = [ 2 , 13 , 17 , 30 , 45 ] NEW_LINE n1 = len ( ar1 ) NEW_LINE n2 = len ( ar2 ) NEW_LINE if n1 == n2 : NEW_LINE INDENT print ( "" Median ▁ is ▁ "" , getMedian ( ar1 , ar2 , n1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size "" ) NEW_LINE DEDENT","class Main(): @staticmethod def get_median(ar1, ar2, n): i = j = count = 0 m1 = m2 = -1 for count in range(n+1): if (i == n): m1 = m2 m2 = ar2[0] break elif (j == n): m1 = m2 m2 = ar1[0] break if (ar1[i] <= ar2[j]): m1 = m2 m2 = ar1[i] i += 1 else: m1 = m2 m2 = ar2[j] j += 1 return (m1 + m2) // 2 def main(args): ar1 = [1, 12, 15, 26, 38] ar2 = [2, 13, 17, 30, 45] n1 = len(ar1) n2 = len(ar2) if (n1 == n2): print(""Median is"", Main.get_median(ar1, ar2, n1)) else: print(""arrays are of unequal size"") ",9.065803050994873,0.6572470563182197,0.5452872980751057,0.3923534663518505,0.823529411764706,0.521706249975707
13443,Java,Python,"class GFG { static int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( seriesSum ( 1 , 1 , N ) ) ; } }","def seriesSum ( calculated , current , N ) : NEW_LINE INDENT i = calculated ; NEW_LINE cur = 1 ; NEW_LINE if ( current == N + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( i < calculated + current ) : NEW_LINE INDENT cur *= i ; NEW_LINE i += 1 ; NEW_LINE DEDENT return cur + seriesSum ( i , current + 1 , N ) ; NEW_LINE DEDENT N = 5 ; NEW_LINE print ( seriesSum ( 1 , 1 , N ) ) ; NEW_LINE","def series_sum(calculated, current, N): cur = 1 if current == N + 1: return 0 for i in range(calculated, calculated + current): cur *= i return cur + series_sum(current, current+1, N) N = 5 print(series_sum(0, 1, N)) ",1.8871769905090332,0.5157736937211921,0.41254962473115186,0.26342823609118543,0.6666666666666665,0.38439976526382974
2291,Java,Python,"import java . util . * ; import java . util . Arrays ; class GFG { public static List < Integer > findDisappearedNumbers ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; i ++ ) { int index = Math . abs ( nums [ i ] ) ; if ( nums [ index - 1 ] > 0 ) { nums [ index - 1 ] *= - 1 ; } } List < Integer > res = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { res . add ( i + 1 ) ; } } return res ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 4 , 5 , 6 } ; System . out . println ( findDisappearedNumbers ( a ) ) ; } }","def getMissingNo ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE sum_of_A = sum ( A ) NEW_LINE return total - sum_of_A NEW_LINE DEDENT A = [ 1 , 2 , 4 , 5 , 6 ] NEW_LINE miss = getMissingNo ( A ) NEW_LINE print ( miss ) NEW_LINE","class Solution: @staticmethod def find_disappeared_numbers(nums): for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] > 0: nums[index] *= -1 res = [i+1 for i in range(len(nums)) if nums[i] > 0] return res if __name<｜begin▁of▁sentence｜>__ == ""main"": a = [1, 2, 4, 5, 6] print(Solution.find_disappeared_numbers(a)) ",3.2188169956207275,0.3592233009708738,0.22204765019424683,0.14477826730920978,0.5,0.2513447871164468
4857,Java,Python,"import java . io . * ; class PancakeSort { static void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } static int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } static int pancakeSort ( int arr [ ] , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; } static void printArray ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( "" "" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = arr . length ; pancakeSort ( arr , n ) ; System . out . println ( "" Sorted ▁ Array : ▁ "" ) ; printArray ( arr , n ) ; } }","def flip ( arr , i ) : NEW_LINE INDENT start = 0 NEW_LINE while start < i : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE start += 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT def findMax ( arr , n ) : NEW_LINE INDENT mi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ mi ] : NEW_LINE INDENT mi = i NEW_LINE DEDENT DEDENT return mi NEW_LINE DEDENT def pancakeSort ( arr , n ) : NEW_LINE INDENT curr_size = n NEW_LINE while curr_size > 1 : NEW_LINE INDENT mi = findMax ( arr , curr_size ) NEW_LINE if mi != curr_size - 1 : NEW_LINE INDENT flip ( arr , mi ) NEW_LINE flip ( arr , curr_size - 1 ) NEW_LINE DEDENT curr_size -= 1 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( "" % d "" % ( arr [ i ] ) , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 23 , 10 , 20 , 11 , 12 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE pancakeSort ( arr , n ) ; NEW_LINE print ( "" Sorted ▁ Array ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE","def flip(arr, i): start = 0 while start < i: temp = arr[start] arr[start] = arr[i] arr[i] = temp start += 1 i -= 1 def findMax(arr, n): mi, i = 0, 0 for i in range(n): if arr[i] > arr[mi]: mi = i return mi def pancakeSort(arr, n): for curr_size in range(n, 1, -1): mi = findMax(arr, curr_size) if mi != curr_size-1: flip(arr, mi) flip(arr, curr<｜begin▁of▁sentence｜>",5.511610984802246,0.3483298760423385,0.29835494194922807,0.22120832931605758,1.0,0.4548458305212403
1844,Java,Python,"import java . util . * ; class MinimumCostPath { private static int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } private static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . println ( minCost ( cost , 2 , 2 ) ) ; } }","R = 3 NEW_LINE C = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE","class MinimumCostPath: @staticmethod def min_cost(costs, m, n): tc = [[0 for _ in range(n + 1)] for _ in range(m + 1)] tc[0][0] = costs[0][0] for i in range(1, m+1): tc[i][0] = tc[i-1][0] + costs[i][0] for j in range(1, n + 1): tc[0][j] = tc[0][j - 1] + costs[0][j] for i in range(1, m+1): for j in range(1, n + 1): tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + costs[i][j] return tc[m][n] @staticmethod def min_(x, y, z): if x < y: return x if x < z else z else: return y if y < z else z def main(): costs = [[1, 2, 3], [4, 8, 2], [1, 5, 3]] print(MinimumCostPath.min_cost(costs, 2, 2)) if __name__ == ""__main__"": main() ",8.167123794555664,0.7473684210526316,0.6863327411532597,0.5713652970431697,0.7272727272727273,0.618137526112037
2012,Java,Python,import java . io . * ; class GFG { static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } public static void main ( String [ ] args ) { int n = 578 ; System . out . println ( count ( n ) ) ; } },def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT n = 578 NEW_LINE print count ( n ) NEW_LINE,def count(n): if n < 3: return n if n >= 3 and n < 10: return n - 1 po = 1 while n / po > 9: po *= 10 msd = n // po if msd != 3: return count(msd) * count(po - 1) + count(msd) + count(n % po) else: return count(msd * po - 1 ) n = 578 print(count(n)) ,3.3578009605407715,0.7333349509513453,0.6575473325051403,0.5293997083581701,0.923076923076923,0.6475028727737959
13911,Java,Python,"import java . io . * ; class GFG { static int INT_MAX = 2147483647 ; static int isKthBitSet ( int x , int k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; } static int leftmostSetBit ( int x ) { int count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; } static int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } static int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( findNthPalindrome ( n ) ) ; } }","INT_MAX = 2147483647 NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT return 1 if ( x & ( 1 << ( k - 1 ) ) ) else 0 NEW_LINE DEDENT def leftmostSetBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def isBinPalindrome ( x ) : NEW_LINE INDENT l = leftmostSetBit ( x ) NEW_LINE r = 1 NEW_LINE while ( l > r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def findNthPalindrome ( n ) : NEW_LINE INDENT pal_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 1 , INT_MAX + 1 ) : NEW_LINE INDENT if ( isBinPalindrome ( i ) ) : NEW_LINE INDENT pal_count += 1 NEW_LINE DEDENT if ( pal_count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 9 NEW_LINE print ( findNthPalindrome ( n ) ) NEW_LINE DEDENT","class GFG: INT_MAX = 2147483647 @staticmethod def isKthBitSet(x, k): return (((x & (1 << (k - 1))) > 0) and 1 or 0) @staticmethod def leftmostSetBit(x): count = 0 while x > 0: count += 1 x = x >> 1 return count @staticmethod def isBinPalindrome(x): l = GFG.leftmostSetBit(x) r = 1 while l > r: if GFG.isKthBitSet(x, l) != GFG.isKthBitSet(x, r): return 0 l -= 1 r += 1 return 1 @staticmethod def findNthPalindrome(n): pal_count = 0 i = 0 for i in range(1, GFG.INT_MAX+1): if GFG.isBinPalindrome(i) > 0: pal_count += 1 if pal_count == n: break return i print(GFG.findNthPalindrome(9)) ",9.660398721694946,0.6068132324963034,0.4899106224004677,0.31990152911485453,0.75,0.44893107038039815
9298,Java,Python,"import java . io . * ; class GFG { static void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; System . out . println ( "" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ "" + Perimeter ) ; } public static void main ( String [ ] args ) { CalPeri ( ) ; } }","def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( "" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ "" , Perimeter ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT CalPeri ( ) ; NEW_LINE DEDENT","class GFG: @staticmethod def calc_peri(): s = 5 perimeter = 10 * s print(""The Perimeter of a Decagon is : "", perimeter) GFG.calc_peri() ",1.5590500831604004,0.39620522697363175,0.27309812183849635,0.12460806074235249,0.6666666666666666,0.2872256425196467
1704,Java,Python,"class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; System . out . println ( "" The ▁ two ▁ repeating ▁ elements ▁ are ▁ : "" ) ; System . out . print ( x + "" ▁ "" + y ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }","import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 ; NEW_LINE P = 1 ; NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( "" The ▁ two ▁ Repeating ▁ elements ▁ are ▁ "" , ( int ) ( x ) , "" ▁ & ▁ "" , ( int ) ( y ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * fact ( n - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE","class RepeatElement: def printRepeating(self, arr, size): S = 0 P = 1 D = 0 n = size - 2 for i in range(size): S += arr[i] P *= arr[i] S = S - n * (n + 1) // 2 P = P // self.fact(n) D = (int)((S*S-4*P)**0.5) x = (D+S)//2 y = (S-D)//2 print(""The two repeating elements are: "", x, "" and "", y) def fact(self, n): return 1 if n == 0 else n * self.fact(n - 1) if __name__ == ""__main__"": repeat = RepeatElement() arr = [4, 2, 4, 5, 2, 3, 1] arr_size = len(arr) repeat.printRepeating(arr, arr_size) ",6.832589149475098,0.6549245145499947,0.5326874778979437,0.3513679345452384,0.7999999999999999,0.48595755418166686
13537,Java,Python,"import java . io . * ; class GFG { static double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . printf ( "" Sum ▁ is ▁ % f "" , sum ( n ) ) ; } }","def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( "" Sum ▁ is "" , round ( sum ( n ) , 6 ) ) NEW_LINE","def sum_(n): s = 0.0 for i in range(1, n + 1): s = s + (1 / i) return s if __name__ == ""__main__"": n = 5 print(""Sum is % f"" % sum_(n)) ",3.4861581325531006,0.6341639440756631,0.5283825957706305,0.35142131820569683,0.9090909090909091,0.5187221954712604
13913,Java,Python,"class GFG { static int INT_SIZE = 32 ; static int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ ] = new int [ INT_SIZE ] ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } static int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . printf ( "" % d "" , getNthNumber ( n ) ) ; } }","INT_SIZE = 32 NEW_LINE def constructNthNumber ( group_no , aux_num , op ) : NEW_LINE INDENT a = [ 0 ] * INT_SIZE NEW_LINE num , i = 0 , 0 NEW_LINE if op == 2 : NEW_LINE INDENT len_f = 2 * group_no NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif op == 0 : NEW_LINE INDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 0 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len_f ) : NEW_LINE INDENT num += ( 1 << i ) * a [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT def getNthNumber ( n ) : NEW_LINE INDENT group_no = 0 NEW_LINE count_upto_group , count_temp = 0 , 1 NEW_LINE while count_temp < n : NEW_LINE INDENT group_no += 1 NEW_LINE count_upto_group = count_temp NEW_LINE count_temp += 3 * ( 1 << ( group_no - 1 ) ) NEW_LINE DEDENT group_offset = n - count_upto_group - 1 NEW_LINE if ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) : NEW_LINE INDENT aux_num = group_offset NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) : NEW_LINE else : NEW_LINE aux_num = ( ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) // 2 ) NEW_LINE DEDENT return constructNthNumber ( group_no , aux_num , op ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 9 NEW_LINE print ( getNthNumber ( n ) ) NEW_LINE DEDENT","class GFG: INT_SIZE = 32 @staticmethod def constructNthNumber(group_no, aux_num, op): a = [0] * GFG.INT_SIZE num = 0 if op == 2: len_f = 2 * group_no a[len_f - 1], a[0] = 1, 1 while aux_num > 0: a[group_no + i] = a[group_no - 1 - i] = aux_num & 1 aux_num = aux_num >> 1 i += 1 elif op == 0: len_f = 2 * group_no + 1 a[len_f - 1], a[0] = 1, 1 if group_no > 0 : a[group_no] = 0 while aux_num > 0: a[group_no + i + 1] = a[group_no - 1 - i] = aux_num & 1 aux_num = aux_num >> 1 i += 1 else : len_f = 2 * group_no + 1 a[len_f - 1], a[0] = 1, 1 if group_no > 0: a[group_no] = 1 while aux_num > 0: a[group_no + i + 1] = a[group_no - 1 - i] = aux_num & 1 aux_num = aux_num >> 1 i += 1 for i in range(len_f): num += (2 ** i) * a[i] return num @staticmethod def getNthNumber(n): group_no = 0 count_upto_group = count_temp = 0 while count_temp < n: group_no += 1 count_upto_group = count_temp count_temp += 3 * (2 **( group_no - 1)) group_offset = n - count_upto_group - 1 if (group_offset + 1) <= (2**(group_no-1)): aux_num = group_offset else : if ((group_offset + 1 ) - (2 ** (group_no - 1))) % 2 == 1: pass # Do nothing, as Python uses dynamic typing and does not require explicit variable declaration for 'else' block. else : aux_num = (( group_offset) - (2**(group_no-1))) // 2 return GFG.constructNthNumber(group_no, aux_num, op) # It seems we are not assigning the value of `op` anywhere. Should it be declared as a method argument? if __name__ == ""__main__"": n = 9 print (GFG.getNthNumber(n)) ",22.467777013778687,0.7708269412707519,0.6718407760418748,0.5088086039783183,0.8,0.5961660227848228
11721,Java,Python,"import java . util . * ; import java . text . DecimalFormat ; class GFG { static void midptellipse ( float rx , float ry , float xc , float yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25f * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; DecimalFormat df = new DecimalFormat ( "" # , # # # , # #0.00000"" ) ; while ( dx < dy ) { System . out . println ( df . format ( ( x + xc ) ) + "" , ▁ "" + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + "" , ▁ "" + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + "" , ▁ "" + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + "" , ▁ "" + df . format ( ( - y + yc ) ) ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5f ) * ( x + 0.5f ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { System . out . println ( df . format ( ( x + xc ) ) + "" , ▁ "" + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + "" , ▁ "" + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + "" , ▁ "" + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + "" , ▁ "" + df . format ( ( - y + yc ) ) ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } public static void main ( String args [ ] ) { midptellipse ( 10 , 15 , 50 , 50 ) ; } }","def midptellipse ( rx , ry , xc , yc ) : NEW_LINE INDENT x = 0 ; NEW_LINE y = ry ; NEW_LINE d1 = ( ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ) ; NEW_LINE dx = 2 * ry * ry * x ; NEW_LINE dy = 2 * rx * rx * y ; NEW_LINE while ( dx < dy ) : NEW_LINE INDENT print ( "" ( "" , x + xc , "" , "" , y + yc , "" ) "" ) ; NEW_LINE print ( "" ( "" , - x + xc , "" , "" , y + yc , "" ) "" ) ; NEW_LINE print ( "" ( "" , x + xc , "" , "" , - y + yc , "" ) "" ) ; NEW_LINE print ( "" ( "" , - x + xc , "" , "" , - y + yc , "" ) "" ) ; NEW_LINE if ( d1 < 0 ) : NEW_LINE INDENT x += 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE d1 = d1 + dx + ( ry * ry ) ; NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 ; NEW_LINE y -= 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d1 = d1 + dx - dy + ( ry * ry ) ; NEW_LINE DEDENT DEDENT d2 = ( ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ) ; NEW_LINE while ( y >= 0 ) : NEW_LINE INDENT print ( "" ( "" , x + xc , "" , "" , y + yc , "" ) "" ) ; NEW_LINE print ( "" ( "" , - x + xc , "" , "" , y + yc , "" ) "" ) ; NEW_LINE print ( "" ( "" , x + xc , "" , "" , - y + yc , "" ) "" ) ; NEW_LINE print ( "" ( "" , - x + xc , "" , "" , - y + yc , "" ) "" ) ; NEW_LINE if ( d2 > 0 ) : NEW_LINE INDENT y -= 1 ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d2 = d2 + ( rx * rx ) - dy ; NEW_LINE DEDENT else : NEW_LINE INDENT y -= 1 ; NEW_LINE x += 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d2 = d2 + dx - dy + ( rx * rx ) ; NEW_LINE DEDENT DEDENT DEDENT midptellipse ( 10 , 15 , 50 , 50 ) ; NEW_LINE","def midptellipse(rx, ry, xc, yc): dx = 0 dy = ry * ry d1 = (ry * ry) - (rx * rx * ry) + ((rx*rx)/4) dx = 2 * ry * ry * dx dy = 2 * rx * rx * dy while(dx < dy): print((( x + xc )), "","", ""▁"" , (( y + yc ))) print(((- x + xc )), "","",""▁"", (( y + yc ))) print((( x + xc )), "","", ""▁"" , ((- y + yc ))) print(((- x + xc )), "","", ""▁"" , ((- y + yc ))) if d1 < 0: x += 1; dx = dx + 2 * ry * ry ; d1 = d1 + dx + (ry * ry) else: x += 1; y -= 1; dx = dx + 2 * ry * ry ; dy = dy - 2 * rx * rx ; d1 = d1 + dx - dy + (rx * rx) d2 = ((ry*ry)*((x+0.5)**2))+(((rx*rx)*((y-1)**2)))-(rx*rx*ry*ry) while y >= 0: print((( x + xc )), "","", ""▁"" , (( y + yc ))) print(((- x + xc )), "","",""▁"", (( y + yc ))) print((( x + xc )), "","", ""▁"" , ((- y + yc ))) print(((- x + xc )), "","", ""▁"" , ((- y + yc ))) if d2 > 0: y -= 1; dy = dy - 2 * rx * rx ; d2 = d2 + 2 * ry * ry - dy else: y -= 1; x += 1; dx = dx + 2 * ry * ry ; dy = dy - 2 * rx * rx ; d2 = d2 + dx - dy + 2 * rx * rx if __name__ == ""__main__"": midptellipse(10, 15, 50, 50) ",20.183146953582764,0.7647070328963841,0.622461851267727,0.4214577677328524,1.0,0.5950204374129966
2065,Java,Python,"class GFG { static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( "" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ "" + getSingle ( arr , n ) ) ; } }","def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ "" , getSingle ( arr , n ) ) NEW_LINE","class GFG: @staticmethod def getSingle(arr, n): ones = twos = 0 common_bit_mask = 0 for i in range(n): twos |= (ones & arr[i]) ones ^= arr[i] common_bit_mask = ~(ones & twos) ones &= common_bit_mask twos &= common_bit_mask return ones if __name__ == ""__main__"": arr = [3, 3, 2, 3] n = len(arr) print(""The element with single occurrence is"", GFG.getSingle(arr, n)) ",4.1383092403411865,0.7489122157759186,0.6480161937548528,0.4934431041237482,0.8571428571428571,0.6025530300294808
13427,Java,Python,"import java . io . * ; import java . math . * ; class GFG { static void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) System . out . println ( "" Even "" ) ; else System . out . println ( "" Odd "" ) ; } public static void main ( String args [ ] ) { System . out . print ( "" The ▁ count ▁ of ▁ divisor : ▁ "" ) ; countDivisors ( 10 ) ; } }","import math NEW_LINE def countDivisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( "" Even "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Odd "" ) NEW_LINE DEDENT DEDENT print ( "" The ▁ count ▁ of ▁ divisor : ▁ "" ) NEW_LINE countDivisors ( 10 ) NEW_LINE","import math class GFG: @staticmethod def count_divisors(n): count = 0 for i in range(1, int(math.sqrt(n))+2): if n % i == 0: count += 2 if n / i != i else 1 return ""Even"" if count % 2 == 0 else ""Odd"" def main(self): print(""The count of divisor: "", end = '') print(self.count_divisors(10)) GFG().main() ",5.0746119022369385,0.558866101410846,0.3762695275700537,0.19996294930063285,0.8571428571428571,0.3971169216533001
848,Java,Python,"class GFG { private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( "" n ▁ Found ▁ at ▁ "" + i + "" ▁ "" + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( "" n ▁ Element ▁ not ▁ found "" ) ; return ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; } }","def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( "" n ▁ Found ▁ at ▁ "" , i , "" , ▁ "" , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( "" Element ▁ not ▁ found "" ) NEW_LINE return 0 NEW_LINE DEDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] NEW_LINE search ( mat , 4 , 29 ) NEW_LINE","class GFG: @staticmethod def search(mat, n, x): i = 0 j = n - 1 while (i < n and j >= 0): if mat[i][j] == x: print(""Found at "" + str(i) + "" "" + str(j)) return elif mat[i][j] > x: j -= 1 else: i += 1 print(""Element not found"") def main(): mat = [[10, 20, 30, 40], [15, 25, 35, 45], [27, 29, 37, 48], [32, 33, 39, 50]] GFG.search(mat, 4, 29) GFG.main() ",6.39630913734436,0.7520963029734888,0.6633007610083788,0.5570944116033308,0.8750000000000001,0.6524660881223316
1954,Java,Python,"public class Main { public final static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat . charAt ( i ) ) % q ; t = ( d * t + txt . charAt ( i ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; } if ( j == M ) System . out . println ( "" Pattern ▁ found ▁ at ▁ index ▁ "" + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt . charAt ( i ) * h ) + txt . charAt ( i + M ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void main ( String [ ] args ) { String txt = "" GEEKS ▁ FOR ▁ GEEKS "" ; String pat = "" GEEK "" ; int q = 101 ; search ( pat , txt , q ) ; } }","d = 256 NEW_LINE def search ( pat , txt , q ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE p = 0 NEW_LINE t = 0 NEW_LINE h = 1 NEW_LINE for i in xrange ( M - 1 ) : NEW_LINE INDENT h = ( h * d ) % q NEW_LINE DEDENT for i in xrange ( M ) : NEW_LINE INDENT p = ( d * p + ord ( pat [ i ] ) ) % q NEW_LINE t = ( d * t + ord ( txt [ i ] ) ) % q NEW_LINE DEDENT for i in xrange ( N - M + 1 ) : NEW_LINE INDENT if p == t : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT else : j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print "" Pattern ▁ found ▁ at ▁ index ▁ "" + str ( i ) NEW_LINE DEDENT DEDENT if i < N - M : NEW_LINE INDENT t = ( d * ( t - ord ( txt [ i ] ) * h ) + ord ( txt [ i + M ] ) ) % q NEW_LINE if t < 0 : NEW_LINE INDENT t = t + q NEW_LINE DEDENT DEDENT DEDENT DEDENT txt = "" GEEKS ▁ FOR ▁ GEEKS "" NEW_LINE pat = "" GEEK "" NEW_LINE q = 101 NEW_LINE search ( pat , txt , q ) NEW_LINE","class Main: d = 256 # public final static int d = 256; @staticmethod def search(pat, txt, q): # void search (String pat , String txt , int q) { M = len(pat) # int M = pat . length () ; N = len(txt) # int N = txt . length () ; i, j = 0, 0 # int i , j; p = t = h = 0 # int p = 0; int t = 0; int h = 1; for _ in range(M - 1): # for (i=0; i< M - 1; i ++) h = (h * Main.d) % q for i in range(M): # for (i=0; i< M; i ++) p = (Main.d * p + ord(pat[i])) % q t = (Main.d * t + ord(txt[i])) % q for i in range(N - M + 1): # for (i=0; i<= N - M ; i ++) if p == t: # if (p == t) for j in range(M): # for (j=0; j< M; j ++) if txt[i + j] != pat[j]: break if j + 1 == M: print(""Pattern found at index"", i) if i < N - M: # Check for next window in text t = (Main.d * (t - ord(txt[i]) * h) + ord(txt[i + M])) % q if t < 0: t += q if __name<｜begin▁of▁sentence｜>__main__': txt = ""GEEKS FOR GEEKS"" # String txt = “GEEKS FOR GEEKS”; pat = ""GEEK"" # String pat = “GEEK”; q = 101 # int q = 101; Main.search(pat, txt, q) ",14.214933156967163,0.5580808080808081,0.48282746697883533,0.3654251136603608,0.8000000000000002,0.49579757956225257
13546,Java,Python,"class Test { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( "" GCD ▁ of ▁ "" + a + "" ▁ and ▁ "" + b + "" ▁ is ▁ "" + gcd ( a , b ) ) ; } }","def gcd ( a , b ) : ' NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT","class Test: @staticmethod def gcd(a, b): if b == 0: return a return Test.gcd(b, a % b) Test = Test() a = 98 b = 56 print(""GCD of "" + str(a) + "" and "" + str(b) + "" is "" + str(test.gcd(a, b))) ",3.350181818008423,0.5102211286627809,0.39015049880875263,0.24125363261353813,0.7692307692307692,0.39964677359870737
2096,Java,Python,"class GFG { static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } public static void main ( String [ ] args ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) == 1 ) System . out . println ( test_no + "" ▁ is ▁ a ▁ power ▁ of ▁ 4"" ) ; else System . out . println ( test_no + "" is ▁ not ▁ a ▁ power ▁ of ▁ 4"" ) ; } }","def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( 64 ) ) : NEW_LINE INDENT print ( test_no , ' is ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , ' is ▁ not ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT","class GFG: @staticmethod def isPowerOfFour(n): if n == 0: return 0 while n != 1: if n % 4 != 0: return 0 n = n / 4 return 1 if __name__ == ""__main__"": test_no = 64 if GFG.isPowerOfFour(test_no) == 1: print(f""{test_no} is a power of 4"") else: print(f""{test_no} is not a power of 4"") ",2.980762004852295,0.5106188922430991,0.31791529563153276,0.16293322270072852,0.823529411764706,0.36111207941992174
7050,Java,Python,"class GFG { static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = arr . length ; System . out . println ( "" Sum ▁ of ▁ maximum ▁ sum ▁ "" + "" increasing ▁ subsequence ▁ is ▁ "" + maxSumIS ( arr , n ) ) ; } }","def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ "" + "" subsequence ▁ is ▁ "" + str ( maxSumIS ( arr , n ) ) ) NEW_LINE","def maxSumIS( arr ): n = len(arr) msis = [i for i in arr] # Initialize msis array same as input array max = 0 # Initialize maximum sum to 0 # Compute optimized maximum sum increasing subsequence values in bottom up manner. for i in range(1, n): for j in range(i): if arr[i] > arr[j] and msis[i] < msis[j] + arr[i]: msis[i] = msis[j] + arr[i] # Update maximum sum increasing subsequence # Pick maximum of all sums. for i in range(len(msis)): if max < msis[i]: max = msis[i] # Updating max with the maximum value from array msis[] return max # Returning max sum of increasing subsequence # Driver Code if __name__ == ""__main__"": arr= [1, 101, 2, 3, 100, 4, 5] print(""Sum of maximum sum increasing subsequence is"", maxSumIS(arr)) ",9.065466165542603,0.6872037914691943,0.5944906162048191,0.47201880020122583,0.8235294117647058,0.5774719836702699
8947,Java,Python,"import java . io . * ; class GFG { static int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; } public static void main ( String args [ ] ) { int A = 2 , B = 5 , C = 13 ; System . out . println ( "" Power ▁ is ▁ "" + exponentMod ( A , B , C ) ) ; } }","def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( ( y + C ) % C ) NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 13 NEW_LINE print ( "" Power ▁ is "" , exponentMod ( A , B , C ) ) NEW_LINE","def exponent_mod(A, B, C): if A == 0: return 0 if B == 0: return 1 y = exponent_mod(A, B//2, C) if B%2==0 else A % C y = (y*y) % C if B%2==0 else (y*(exponent_mod(A, B-1, C))) % C return (y+C) % C print(""Power is"", exponent_mod(2,5,13)) ",2.698594093322754,0.43440325110870376,0.330217658766808,0.18769437886837845,1.0,0.43138606520786493
9368,Java,Python,"import java . util . * ; class solution { static void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 1st ▁ octant "" ) ; else if ( x < 0 && y >= 0 && z >= 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 2nd ▁ octant "" ) ; else if ( x < 0 && y < 0 && z >= 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 3rd ▁ octant "" ) ; else if ( x >= 0 && y < 0 && z >= 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 4th ▁ octant "" ) ; else if ( x >= 0 && y >= 0 && z < 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 5th ▁ octant "" ) ; else if ( x < 0 && y >= 0 && z < 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 6th ▁ octant "" ) ; else if ( x < 0 && y < 0 && z < 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 7th ▁ octant "" ) ; else if ( x >= 0 && y < 0 && z < 0 ) System . out . println ( "" Point ▁ lies ▁ in ▁ 8th ▁ octant "" ) ; } public static void main ( String args [ ] ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = - 4 ; y = 2 ; z = - 8 ; octant ( x , y , z ) ; x = - 6 ; y = - 2 ; z = 8 ; octant ( x , y , z ) ; } }","def octant ( x , y , z ) : NEW_LINE INDENT if x >= 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 1st ▁ octant "" NEW_LINE DEDENT elif x < 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 2nd ▁ octant "" NEW_LINE DEDENT elif x < 0 and y < 0 and z >= 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 3rd ▁ octant "" NEW_LINE DEDENT elif x >= 0 and y < 0 and z >= 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 4th ▁ octant "" NEW_LINE DEDENT elif x >= 0 and y >= 0 and z < 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 5th ▁ octant "" NEW_LINE DEDENT elif x < 0 and y >= 0 and z < 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 6th ▁ octant "" NEW_LINE DEDENT elif x < 0 and y < 0 and z < 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 7th ▁ octant "" NEW_LINE DEDENT elif x >= 0 and y < 0 and z < 0 : NEW_LINE INDENT print "" Point ▁ lies ▁ in ▁ 8th ▁ octant "" NEW_LINE DEDENT DEDENT x , y , z = 2 , 3 , 4 NEW_LINE octant ( x , y , z ) NEW_LINE x , y , z = - 4 , 2 , - 8 NEW_LINE octant ( x , y , z ) NEW_LINE x , y , z = - 6 , - 2 , 8 NEW_LINE octant ( x , y , z ) NEW_LINE","def octant(x, y, z): if x >= 0 and y >= 0 and z >= 0: print(""Point lies in 1st Octant"") elif x < 0 and y >= 0 and z >= 0: print(""Point lies in 2nd Octant"") elif x < 0 and y < 0 and z >= 0: print(""Point lies in 3rd Octant"") elif x >= 0 and y < 0 and z >= 0: print(""Point lies in 4th Octant"") elif x >= 0 and y >= 0 and z < 0: print(""Point lies in 5th Octant"") elif x < 0 and y >= 0 and z < 0: print(""Point lies in 6th Octant"") elif x < 0 and y < 0 and z < 0: print(""Point lies in 7th Octant"") else: print(""Point lies in 8th Octant"") x = 2 y = 3 z = 4 octant(x, y, z) x = -4 y = 2 z = -8 octant(x, y, z) x = -6 y = -2 z = 8 octant(x, y, z) ",9.827601909637451,0.6001946791792174,0.4940746078922522,0.3999055856731504,0.9090909090909091,0.552661182698478
2090,Java,Python,class GFG { static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void main ( String [ ] args ) { System . out . println ( addOne ( 13 ) ) ; } },def addOne ( x ) : NEW_LINE INDENT m = 1 ; NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT n = 13 NEW_LINE print addOne ( n ) NEW_LINE,class GFG: @staticmethod def add_one(x): m = 1 while (x & m) >= 1: x = x ^ m m <<= 1 x = x ^ m return x print(GFG.add_one(13)) ,2.174247980117798,0.6662325923841765,0.530836308581981,0.3571498018819075,0.8571428571428571,0.5071477184601924
12740,Java,Python,import java . io . * ; class GFG { static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( divisorSum ( n ) ) ; n = 5 ; System . out . println ( divisorSum ( n ) ) ; } },"' NEW_LINE ' NEW_LINE def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE","def divisor_sum(n): sum = 0 for i in range(1, n + 1): sum += (n // i) * i return sum n=4 print(divisor_sum(n)) n=5 print(divisor_sum(n)) ",1.547745943069458,0.5197721554844307,0.4364746785816359,0.29927032656302355,1.0,0.5094892285941165
12813,Java,Python,"import static java . lang . Math . pow ; class GFG { static double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( Math . pow ( x , i ) / i ) ; return total ; } public static void main ( String [ ] args ) { int x = 2 ; int n = 5 ; System . out . printf ( "" % .2f "" , sum ( x , n ) ) ; } }","def SUM ( x , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + ( ( x ** i ) / i ) NEW_LINE DEDENT return total NEW_LINE DEDENT x = 2 NEW_LINE n = 5 NEW_LINE s = SUM ( x , n ) NEW_LINE print ( round ( s , 2 ) ) NEW_LINE","import math def sum_(x, n): total = 1.0 for i in range(1, n+1): total += (math.pow(x, i) / i) return total if __name__ == ""__main__"": x = 2 n = 5 print(""%.2f"" % sum_(x, n)) ",2.225689172744751,0.5789330436610753,0.47371889917339977,0.297829830386645,0.8,0.4484808812706515
12673,Java,Python,import java . io . * ; public class GFG { static float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } },def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( AvgofSquareN ( n ) ) ; NEW_LINE,def avg_of_square_n(n): return (((n + 1) * (2 * n + 1)) / 6) n = 2 print(avg_of_square_n(n)) ,1.4845960140228271,0.731815035934027,0.6690063520830041,0.5490079724806428,1.0,0.68430558073645
7057,Java,Python,"class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }","def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print knapSack ( W , wt , val , n ) NEW_LINE","class Knapsack: @staticmethod def max(a, b): return a if a > b else b @staticmethod def knapSack(W, wt, val, n): if n == 0 or W == 0: return 0 if wt[n - 1] > W: return Knapsack.knapSack(W, wt, val, n - 1) else: return Knapsack.max(val[n - 1] + Knapsack.knapSack(W - wt[n - 1], wt, val, n - 1), Knapsack.knapSack(W, wt, val, n - 1)) if __name__ == ""__main__"": val = [60, 100, 120] wt = [10, 20, 30] W = 50 n = len(val) print(Knapsack.knapSack(W, wt, val, n)) ",6.597136735916138,0.7888198757763976,0.7263079869624633,0.6233241853051941,0.9090909090909091,0.7090542024409086
2149,Java,Python,"class GFG { static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; } public static void main ( String [ ] args ) { int [ ] x = { 10 } ; swap ( x , x ) ; System . out . println ( "" After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ "" + x [ 0 ] ) ; } }","def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT x = [ 10 ] NEW_LINE swap ( x , x ) NEW_LINE print ( "" After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ "" , x [ 0 ] ) NEW_LINE","class GFG: @staticmethod def swap(xp, yp): xp[0] = xp[0] ^ yp[0] yp[0] = xp[0] ^ yp[0] xp[0] = xp[0] ^ yp[0] if __name__ == ""__main__"": x = [10] GFG.swap(x, x) print(""After swap(&x, &x): x ="", x[0]) ",3.536733865737915,0.845176095821129,0.7794041257601939,0.6660458985146748,0.5,0.6162321289602724
8793,Java,Python,"class GFG { static void divideString ( String str , int n ) { int str_size = str . length ( ) ; int part_size ; if ( str_size % n != 0 ) { System . out . println ( "" Invalid ▁ Input : ▁ String ▁ size "" + "" is ▁ not ▁ divisible ▁ by ▁ n "" ) ; return ; } part_size = str_size / n ; for ( int i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) System . out . println ( ) ; System . out . print ( str . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String str = "" a _ simple _ divide _ string _ quest "" ; divideString ( str , 4 ) ; } }","def divideString ( string , n ) : NEW_LINE INDENT str_size = len ( string ) NEW_LINE if str_size % n != 0 : NEW_LINE INDENT print "" Invalid ▁ Input : ▁ String ▁ size ▁ is ▁ not ▁ divisible ▁ by ▁ n "" NEW_LINE return NEW_LINE DEDENT part_size = str_size / n NEW_LINE k = 0 NEW_LINE for i in string : NEW_LINE INDENT if k % part_size == 0 : NEW_LINE INDENT print   "" NEW_LINE DEDENT DEDENT DEDENT "" , NEW_LINE INDENT print i , NEW_LINE k += 1 NEW_LINE DEDENT string = "" a _ simple _ divide _ string _ quest "" NEW_LINE / * length od string is 28 * / NEW_LINE divideString ( string , 4 ) NEW_LINE","class GFG: @staticmethod def divide_string(strr, n): str_size = len(strr) part_size = 0 if str_size % n != 0: print(""Invalid Input: String size is not divisible by n"") return part_size = str_size // n for i in range(str_size): if i % part_size == 0: print() print(strr[i], end="""") if __name__ == ""__main__"": strr = "" a simple divide string quest"" GFG.divide_string(strr, 4) ",5.962502717971802,0.48626978753945904,0.32322557364791743,0.17646787621617496,0.9333333333333333,0.4035275133513224
2142,Java,Python,class GFG { static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } public static void main ( String [ ] args ) { int x = 23 ; System . out . println ( swapBits ( x ) ) ; } },def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT x = 23 NEW_LINE print ( swapBits ( x ) ) NEW_LINE,class GFG: @staticmethod def swap_bits(x): even_bits = x & 0xAAAAAAAA odd_bits = x & 0x55555555 even_bits >>= 1 odd_bits <<= 1 return even_bits | odd_bits @staticmethod def main(): x = 23 print(GFG.swap_bits(x)) GFG.main() ,3.0135018825531006,0.7090909090909091,0.5729597091269405,0.3772284756207513,0.8,0.5040599329345259
1683,Java,Python,"class EquilibriumIndex { int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { EquilibriumIndex equi = new EquilibriumIndex ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . length ; System . out . println ( "" First ▁ equilibrium ▁ index ▁ is ▁ "" + equi . equilibrium ( arr , arr_size ) ) ; } }","def equilibrium ( arr ) : NEW_LINE INDENT total_sum = sum ( arr ) NEW_LINE leftsum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_sum -= num NEW_LINE if leftsum == total_sum : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ - 7 , 1 , 5 , 2 , - 4 , 3 , 0 ] NEW_LINE print ( ' First ▁ equilibrium ▁ index ▁ is ▁ ' , equilibrium ( arr ) ) NEW_LINE","class EquilibriumIndex: def equilibrium(self, arr, n): sum_ = 0 leftsum = 0 for i in range(n): sum_ += arr[i] for i in range(n): sum_ -= arr[i] if leftsum == sum_: return i leftsum += arr[i] return -1 if __name__ == ""__main__"": equi = EquilibriumIndex() arr = [-7, 1, 5, 2, -4, 3, 0] arr_size = len(arr) print(""First equilibrium index is"", equi.equilibrium(arr, arr_size)) ",5.228079319000244,0.504424778761062,0.3551143403050143,0.16847242994133685,0.923076923076923,0.3948537778820127
1862,Java,Python,"class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }","def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE","def max(a, b): return a if a > b else b def knapSack(W, wt, val, n): K = [[0 for _ in range(W + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(W + 1): if i == 0 or w == 0: K[i][w] = 0 elif wt[i - 1] <= w: K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w]) else: K[i][w] = K[i - 1][w] return K[n][W] val = [60, 100, 120] wt = [10, 20, 30] W = 50 n = len(val) print(knapSack(W, wt, val, n)) ",6.99866509437561,0.8653418608126989,0.8263783142145312,0.7467096058849922,1.0,0.8226967241194945
2143,Java,Python,"class GFG { static boolean isPowerOfTwo ( int n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; } public static void main ( String [ ] args ) { int n = 16 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Invalid ▁ number "" ) ; else System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Position ▁ "" + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Invalid ▁ number "" ) ; else System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Position ▁ "" + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Invalid ▁ number "" ) ; else System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Position ▁ "" + pos ) ; } }","def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" , ▁ Invalid ▁ number "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" , ▁ Position ▁ "" , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" , ▁ Invalid ▁ number "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" , ▁ Position ▁ "" , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" , ▁ Invalid ▁ number "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" , ▁ Position ▁ "" , pos ) ; NEW_LINE DEDENT","def is_power_of_two(n): return (n > 0 and ((n & (n - 1)) == 0)) def find_position(n): if not is_power_of_two(n): return -1 i = 1 pos = 1 while ((i & n) == 0): i = i << 1 pos += 1 return pos n=16 pos=findPosition(n) if (pos == -1): print(""n = "",n,"" , Invalid number"") else: print(""n = "",n,"", Position "",pos) n=12 pos=findPosition(n) if (pos == -1): print(""n = "",n,"" , Invalid number"") else: print(""n = "",n,"", Position "",pos) n=128 pos=findPosition(n) if (pos == -1): print(""n = "",n,"" , Invalid number"") else: print(""n = "",n,"", Position "",pos) ",7.295644760131836,0.5149216068379097,0.42896701581687696,0.2781268800630459,0.7999999999999999,0.4346888160441321
1703,Java,Python,"class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( "" Repeated ▁ elements ▁ are ▁ : ▁ "" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + "" ▁ "" ) ; else count [ arr [ i ] ] ++ ; } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }","def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE print ( "" ▁ Repeating ▁ elements ▁ are ▁ "" , end = "" "" ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE","class RepeatElement: def printRepeating(self, arr, size): count = [0]*size print(""Repeated elements are : "", end="""") for i in range(size): if count[arr[i]] == 1: print(arr[i], end="" "") else: count[arr[i]] += 1 if __name<｜begin▁of▁sentence｜>__ == ""<'main'>"": repeat = RepeatElement() arr = [4, 2, 4, 5, 2, 3, 1] arr_size = len(arr) repeat.printRepeating(arr, arr_size) ",5.25876784324646,0.6926131647205712,0.5915187313700084,0.4554371888780877,0.9090909090909091,0.591533304941934
7056,Java,Python,"class EggDrop { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int eggDrop ( int n , int k ) { int eggFloor [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Integer . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } public static void main ( String args [ ] ) { int n = 2 , k = 10 ; System . out . println ( "" Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst "" + "" ▁ case ▁ with ▁ "" + n + "" ▁ eggs ▁ and ▁ "" + k + "" ▁ floors ▁ is ▁ "" + eggDrop ( n , k ) ) ; } }","INT_MAX = 32767 NEW_LINE def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT n = 2 NEW_LINE k = 36 NEW_LINE print ( "" Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst ▁ case ▁ with "" + str ( n ) + "" eggs ▁ and ▁ "" + str ( k ) + "" ▁ floors ▁ is ▁ "" + str ( eggDrop ( n , k ) ) ) NEW_LINE","class EggDrop: @staticmethod def max(a, b): return a if a > b else b @staticmethod def egg_drop(n, k): eggFloor = [[0 for _ in range(k+1)] for _ in range(n+1)] res = 0 for i in range(1, n+1): eggFloor[i][1] = 1 eggFloor[i][0] = 0 for j in range(1, k+1): eggFloor[1][j] = j for i in range(2, n+1): for j in range(2, k+1): eggFloor[i][j] = float('inf') for x in range(1, j+1): res = 1 + max(eggFloor[i-1][x-1], eggFloor[i][j-x]) if res < eggFloor[i][j]: eggFloor[i][j] = res return eggFloor[n][k] if __name__ == ""__main__"": n = 2 k = 10 print(""Minimum number of trials in worst case with"", n, ""eggs and"", k, ""floors is"", EggDrop.egg_drop(n, k)) ",11.806975841522217,0.6550010989903391,0.5617986233845689,0.4261637493044271,0.888888888888889,0.5649812911797656
13544,Java,Python,"class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( "" LCM ▁ of ▁ "" + a + "" ▁ and ▁ "" + b + "" ▁ is ▁ "" + lcm ( a , b ) ) ; } }","def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a / gcd ( a , b ) ) * b NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE","class Test: @staticmethod def gcd(a, b): if a == 0: return b return Test.gcd(b % a, a) @staticmethod def lcm(a, b): return (a // Test.gcd(a, b)) * b if __name__ == ""__main__"": a = 15 b = 20 print(""The LCM of"", a , ""and"", b , ""is"",Test.lcm(a,b)) ",3.0078511238098145,0.7203878561789844,0.6130880031988769,0.4431622976750041,0.9090909090909091,0.5829408810997756
1610,Java,Python,"class MergeArrays { void moveToEnd ( int mPlusN [ ] , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } } void merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( "" "" ) ; } public static void main ( String [ ] args ) { MergeArrays mergearray = new MergeArrays ( ) ; int mPlusN [ ] = { 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = N . length ; int m = mPlusN . length - n ; mergearray . moveToEnd ( mPlusN , m + n ) ; mergearray . merge ( mPlusN , N , m , n ) ; mergearray . printArray ( mPlusN , m + n ) ; } }","NA = - 1 NEW_LINE def moveToEnd ( mPlusN , size ) : NEW_LINE INDENT i = 0 NEW_LINE j = size - 1 NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mPlusN [ i ] != NA ) : NEW_LINE INDENT mPlusN [ j ] = mPlusN [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def merge ( mPlusN , N , m , n ) : NEW_LINE INDENT i = n NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( k < ( m + n ) ) : NEW_LINE INDENT if ( ( j == n ) or ( i < ( m + n ) and mPlusN [ i ] <= N [ j ] ) ) : NEW_LINE INDENT mPlusN [ k ] = mPlusN [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mPlusN [ k ] = N [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , "" ▁ "" , end = "" "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT mPlusN = [ 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 ] NEW_LINE N = [ 5 , 7 , 9 , 25 ] NEW_LINE n = len ( N ) NEW_LINE m = len ( mPlusN ) - n NEW_LINE moveToEnd ( mPlusN , m + n ) NEW_LINE merge ( mPlusN , N , m , n ) NEW_LINE printArray ( mPlusN , m + n ) NEW_LINE","class MergeArrays: def moveToEnd(self, mPlusN, size): i = j = size - 1 for i in range(size - 1, -1, -1): if mPlusN[i] != -1: mPlusN[j] = mPlusN[i] j -= 1 def merge(self, mPlusN, N, m, n): i = n j = 0 k = 0 while k < (m + n): if ((i < (m + n) and mPlusN[i] <= N[j]) or (j == n)): mPlusN[k] = mPlusN[i] k += 1 i += 1 else: mPlusN[k] = N[j] k += 1 j += 1 def printArray(self, arr, size): for i in range(size): print(arr[i], end="" "") print() mergearray = MergeArrays() mPlusN = [2, 8, -1, -1, -1, 13, -1, 15, 20] N = [5, 7, 9, 25] n = len(N) m = len(mPlusN) - n mergearray.moveToEnd(mPlusN, m + n) mergearray.merge(mPlusN, N, m, n) mergearray.printArray(mPlusN, m + n) ",11.589166164398193,0.7477562915793953,0.6686922507110802,0.5183178326763306,0.9411764705882353,0.6451754240499019
11743,Java,Python,"import java . lang . Math ; class GFG { static long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; } public static void main ( String [ ] args ) { int n ; n = 8 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 12 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 102 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 999 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; n = 9999 ; System . out . println ( nthTermOfTheSeries ( n ) ) ; } }","from math import pow NEW_LINE def nthTermOfTheSeries ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nthTerm = pow ( n - 1 , 2 ) + n NEW_LINE DEDENT else : NEW_LINE INDENT nthTerm = pow ( n + 1 , 2 ) + n NEW_LINE DEDENT return nthTerm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 12 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 102 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 999 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 9999 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE DEDENT","import math class GFG: @staticmethod def nth_term_of_the_series(n): if n % 2 == 0: return (math.pow(n - 1, 2) + n) else: return (math.pow(n + 1, 2) + n) if __name__ == ""__main__"": gfg = GFG() print(int(gfg.nth_term_of_the_series(8))) print(int(gfg.nth_term_of_the_series(12))) print(int(gfg.nth_term_of_the_series(102))) print(int(gfg.nth_term_of_the_series(999))) print(int(gfg.nth_term_of_the_series(9999))) ",4.677148342132568,0.5548165825863307,0.4350216137035872,0.2740561024366248,0.8333333333333334,0.44183927170563736
13474,Java,Python,"class GFG { static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; } public static void main ( String [ ] args ) { int m = 4 , n = 3 ; System . out . println ( "" Count ▁ of ▁ squares ▁ is ▁ "" + countSquares ( m , n ) ) ; } }","def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return ( ( m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 4 NEW_LINE n = 3 NEW_LINE print ( "" Count ▁ of ▁ squares ▁ is ▁ "" , countSquares ( m , n ) ) NEW_LINE DEDENT","class GFG: @staticmethod def count_squares(m, n): if n < m: temp = m m = n n = temp return m * (m + 1) * (2 * m + 1) // 6 + (n - m) * m * (m + 1) // 2 if __name__ == ""__main__"": m = 4 n = 3 print(""Count of squares is"", GFG.count_squares(m, n)) ",4.620352029800415,0.6564697779440376,0.554338486777749,0.41857751379660685,0.888888888888889,0.5596709263242914
13562,Java,Python,"class GfG { static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + "" ▁ "" ) ; System . out . println ( ) ; return ; } static void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } static void printSequences ( int n , int k ) { int arr [ ] = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } public static void main ( String [ ] args ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; } }","def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT print ( "" "" ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE","def printArray(arr, size): for i in range(size): print(str(arr[i]) + "" "", end="""") print() return def printSequencesRecur(arr, n, k, index): if k == 0: printArray(arr, index) if k > 0: for i in range(1, n+1): arr[index] = i printSequencesRecur(arr, n, k-1, index+1) def printSequences(n, k): arr = [0]*k printSequencesRecur(arr, n, k, 0) return printSequences(3, 2) ",4.709635019302368,0.5837578859232646,0.48676730466881524,0.3712409962683711,1.0,0.5598686973878597
1955,Java,Python,"class GFG { static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) { System . out . println ( "" Pattern ▁ found ▁ at ▁ index ▁ "" + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } public static void main ( String [ ] args ) { String txt = "" ABCEABCDABCEABCD "" ; String pat = "" ABCD "" ; search ( pat , txt ) ; } }","def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print "" Pattern ▁ found ▁ at ▁ index ▁ "" + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT txt = "" ABCEABCDABCEABCD "" NEW_LINE pat = "" ABCD "" NEW_LINE search ( pat , txt ) NEW_LINE","class GFG: @staticmethod def search(pat, txt): M = len(pat) N = len(txt) i = 0 while (i <= N - M): j = 0 for j in range(M): if txt[i + j] != pat[j]: break if (j == M): print(""Pattern found at index"", i) i = i + M elif (j == 0): i = i + 1 else: i = i + j if __name__=='__main__': txt = ""ABCEABCDABCEABCD"" pat = ""ABCD"" GFG.search(pat, txt) ",6.253780126571655,0.6810683564703849,0.5717005429257307,0.40849907348440484,0.9333333333333333,0.5659493514390833
2018,Java,Python,"import java . io . * ; import java . util . * ; class GFG { static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static int findSmallerInRight ( String str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str . charAt ( i ) < str . charAt ( low ) ) ++ countRight ; return countRight ; } static int findRank ( String str ) { int len = str . length ( ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } public static void main ( String [ ] args ) { String str = "" string "" ; System . out . println ( findRank ( str ) ) ; } }","def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE while n >= 1 : NEW_LINE INDENT f = f * n NEW_LINE n = n - 1 NEW_LINE DEDENT return f NEW_LINE DEDENT def findSmallerInRight ( st , low , high ) : NEW_LINE INDENT countRight = 0 NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if st [ i ] < st [ low ] : NEW_LINE INDENT countRight = countRight + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return countRight NEW_LINE DEDENT def findRank ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE mul = fact ( ln ) NEW_LINE rank = 1 NEW_LINE i = 0 NEW_LINE while i < ln : NEW_LINE INDENT mul = mul / ( ln - i ) NEW_LINE countRight = findSmallerInRight ( st , i , ln - 1 ) NEW_LINE rank = rank + countRight * mul NEW_LINE i = i + 1 NEW_LINE DEDENT return rank NEW_LINE DEDENT st = "" string "" NEW_LINE print ( findRank ( st ) ) NEW_LINE","def fact(n): return 1 if n <= 1 else n * fact(n - 1) def find_smaller_in_right(str, low, high): countRight = 0 for i in range(low + 1, high + 1): if str[i] < str[low]: countRight += 1 return countRight def find_rank(str): lenStr = len(str) mul = fact(lenStr) rank = 1 for i in range(0, lenStr): mul //= lenStr - i countRight = find_smaller_in_right(str, i, lenStr - 1) rank += countRight * mul return rank if __name__ == ""__main__"": str =""string"" print(find_rank(str)) ",7.6639838218688965,0.48005064316505297,0.32815218667774837,0.15254716498741816,0.6,0.28678301549119267
1656,Java,Python,"class Main { static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = arr . length ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) System . out . println ( "" Element ▁ not ▁ found "" ) ; else System . out . println ( "" Element ▁ Found ▁ at ▁ Position : ▁ "" + ( position + 1 ) ) ; } }","def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 12 , 34 , 10 , 6 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE key = 40 NEW_LINE index = findElement ( arr , n , key ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( "" element ▁ found ▁ at ▁ position : ▁ "" + str ( index + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" element ▁ not ▁ found "" ) NEW_LINE DEDENT","class Main: @staticmethod def find_element(arr, n, key): for i in range(n): if arr[i] == key: return i return -1 if __name__ == ""__main__"": arr = [12, 34, 10, 6, 40] n = len(arr) key = 40 position = Main.find_element(arr, n, key) if position == -1: print(""Element not found"") else: print(""Element Found at Position :"", position + 1) ",3.716921806335449,0.5940815923809276,0.4874375619864728,0.3630519915997039,0.9333333333333333,0.5341363941197927
12321,Java,Python,"import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; System . out . println ( "" Distance ▁ is ▁ "" + d ) ; return ; } public static void main ( String [ ] args ) { float x1 = 2 ; float y1 = - 5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } }","import math NEW_LINE def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT d = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) + math . pow ( z2 - z1 , 2 ) * 1.0 ) NEW_LINE print ( "" Distance ▁ is ▁ "" ) NEW_LINE print ( d ) NEW_LINE DEDENT x1 = 2 NEW_LINE y1 = - 5 NEW_LINE z1 = 7 NEW_LINE x2 = 3 NEW_LINE y2 = 4 NEW_LINE z2 = 5 NEW_LINE distance ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE","import math def distance(x1, y1, z1, x2, y2, z2): d = math.pow((math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2))*1.0, 0.5) print(""The distance is"", d) def main(): x1 = 2 y1 = -5 z1 = 7 x2 = 3 y2 = 4 z2 = 5 distance(x1, y1, z1, x2, y2, z2) if __name__ == ""__main__"": main() ",3.967664957046509,0.7297226470068964,0.6384364708440398,0.48861944493733933,0.8571428571428571,0.5991764685989946
2133,Java,Python,class GFG { public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( getFirstSetBitPos ( n ) ) ; } },import math NEW_LINE def getFirstSetBitPos ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT n = 12 NEW_LINE print ( int ( getFirstSetBitPos ( n ) ) ) NEW_LINE,import math class GFG: @staticmethod def get_first_set_bit_pos(n): return int((math.log10(n & -n)) / math.log10(2) + 1) @staticmethod def main(): n = 12 print(GFG.get_first_set_bit_pos(n)) GFG.main() ,2.87143611907959,0.5,0.3960590171906697,0.17302961464039843,0.8571428571428571,0.378263587391136
2190,Java,Python,"class MaximumDiffrence { int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } public static void main ( String [ ] args ) { MaximumDifference maxdif = new MaximumDifference ( ) ; int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; System . out . println ( "" Maximum ▁ difference ▁ is ▁ "" + maxdif . maxDiff ( arr , 5 ) ) ; } }","def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( arr [ j ] - arr [ i ] > max_diff ) : NEW_LINE INDENT max_diff = arr [ j ] - arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 90 , 10 , 110 ] NEW_LINE size = len ( arr ) NEW_LINE print ( "" Maximum ▁ difference ▁ is "" , maxDiff ( arr , size ) ) NEW_LINE","class MaximumDifference: def max_diff(self, arr, arr_size): max_diff = arr[1] - arr[0] for i in range(arr_size): for j in range(i + 1, arr_size): if arr[j] - arr[i] > max_diff: max_diff = arr[j] - arr[i] return max_diff if __name<｜begin▁of▁sentence｜>__ == ""__main__"": maxdif = MaximumDifference() arr = [1, 2, 90, 10, 110] print(""Maximum difference is"", maxdif.max_diff(arr, len(arr))) ",3.6379029750823975,0.7957354422137287,0.6897330403320936,0.5570458191143575,0.923076923076923,0.666855150303127
1715,Java,Python,"class FindTriplet { boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( "" Triplet ▁ is ▁ "" + A [ i ] + "" , ▁ "" + A [ j ] + "" , ▁ "" + A [ k ] ) ; return true ; } } } } return false ; } public static void main ( String [ ] args ) { FindTriplet triplet = new FindTriplet ( ) ; int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = A . length ; triplet . find3Numbers ( A , arr_size , sum ) ; } }","def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( "" Triplet ▁ is "" , A [ i ] , "" , ▁ "" , A [ j ] , "" , ▁ "" , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT A = [ 1 , 4 , 45 , 6 , 10 , 8 ] NEW_LINE sum = 22 NEW_LINE arr_size = len ( A ) NEW_LINE find3Numbers ( A , arr_size , sum ) NEW_LINE","class FindTriplet: def find3Numbers(self, A, arr_size, sum): for i in range(0, arr_size-2): for j in range(i+1, arr_size-1): for k in range(j+1, arr_size): if (A[i] + A[j] + A[k]) == sum: print(""Triplet is"", A[i], "","", A[j], "","", A[k]) return True return False ",7.359636068344116,0.49478021678178286,0.43392328059668767,0.33030607288181435,0.9411764705882353,0.5135671921937406
12963,Java,Python,"import java . util . * ; class GFG { static int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } public static void main ( String [ ] args ) { long n = 345289467 ; System . out . print ( "" Number ▁ of ▁ digits ▁ : ▁ "" + countDigit ( n ) ) ; } }","def countDigit ( n ) : NEW_LINE INDENT if n / 10 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT n = 345289467 NEW_LINE print ( "" Number ▁ of ▁ digits ▁ : ▁ % ▁ d "" % ( countDigit ( n ) ) ) NEW_LINE","def count_digit(n): if n // 10 == 0: return 1 return 1 + count_digit(n // 10) n = 345289467 print(""Number of digits : "", count_digit(n)) ",1.5469779968261719,0.5524083385699148,0.43720210907166024,0.251202244029659,1.0,0.4758415708207613
1788,Java,Python,"class BinarySearch { int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void main ( String args [ ] ) { BinarySearch ob = new BinarySearch ( ) ; int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = ob . binarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . println ( "" Element ▁ not ▁ present "" ) ; else System . out . println ( "" Element ▁ found ▁ at ▁ index ▁ "" + result ) ; } }","def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( "" Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d "" % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Element ▁ is ▁ not ▁ present ▁ in ▁ array "" ) NEW_LINE DEDENT","class BinarySearch: def binary_search(self, arr, l, r, x): if r >= l: mid = l + (r - l) // 2 if arr[mid] == x: return mid elif arr[mid] > x: return self.binary_search(arr, l, mid - 1, x) else: return self.binary_search(arr, mid + 1, r, x) return -1 def main(self): arr = [2, 3, 4, 10, 40] n = len(arr) x = 10 ob = BinarySearch() result = self.binary_search(ob, 0, n - 1, x) if result != -1: print(""Element is found at index"", str(result)) else: print(""Element is not present"") if __name__ == ""__main__"": bs = BinarySearch() bs.main() ",10.937036037445068,0.6744493927084892,0.5751470918263619,0.4472196741124351,0.875,0.5755537718787045
9263,Java,Python,import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double c = 8.0 ; System . out . println ( area_cicumscribed ( c ) ) ; } },PI = 3.14159265 NEW_LINE def area_cicumscribed ( c ) : NEW_LINE INDENT return ( c * c * ( PI / 4 ) ) NEW_LINE DEDENT c = 8.0 NEW_LINE print ( area_cicumscribed ( c ) ) NEW_LINE,"import math class GFG: PI = 3.14159265 @staticmethod def area_circumscribed(c): return c * c * (GFG.PI / 4) # The main method is not translated because it's not needed in Python: # - In Java, the Main method contains code that executes when the program starts executing. This isn’t necessary in Python as every function call can be a full file run. # - In this case, we would just need to use `area_circumscribed` directly like so: print(GFG.area_circumscribed(8)) ",3.834583044052124,0.21359223300970873,0.164992543774673,0.08673744785399222,0.4,0.18071621349779454
12672,Java,Python,import java . io . * ; public class GFG { static float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } },"def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE","def avg_of_square_n(n): sum = 0 for i in range(1, n + 1): sum += (i * i) return sum / n if __name__ == ""__main__"": n = 2 print(avg_of_square_n(n)) ",1.917114019393921,0.7523350590185509,0.6691747927804945,0.5044190889846264,0.888888888888889,0.6197600289559051
2304,Java,Python,"import java . io . * ; class GFG { static void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( "" The ▁ repeating ▁ element ▁ is ▁ "" ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( "" And ▁ the ▁ missing ▁ element ▁ is ▁ "" ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = arr . length ; printTwoElements ( arr , n ) ; } }","def printTwoElements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ repeating ▁ element ▁ is "" , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( "" and ▁ the ▁ missing ▁ element ▁ is "" , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 7 , 3 , 4 , 5 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printTwoElements ( arr , n ) NEW_LINE","import java.io.* class GFG: @staticmethod def printTwoElements(arr, size): i = 0; print('The repeating element is ') for i in range(size): abs_val = abs(arr[i]) if arr[abs_val-1] > 0: arr[abs_val-1] = -arr[abs_val-1] else: print(abs_val) print('And the missing element is ') for i in range(size): if arr[i] > 0: print(i+1) if __name__ == ""__main__"": arr = [7, 3, 4, 5, 5, 6, 2] n = len(arr) GFG.printTwoElements(arr, n) ",7.662777900695801,0.5892009748720317,0.48882554586448906,0.37635759962774845,0.7999999999999999,0.5034503197394239
2148,Java,Python,"import java . io . * ; public class GFG { public static void main ( String a [ ] ) { int x = 10 ; int y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; System . out . println ( "" After ▁ swap : ▁ x ▁ = ▁ "" + x + "" , ▁ y ▁ = ▁ "" + y ) ; } }","x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( "" After ▁ Swapping : ▁ x ▁ = ▁ "" , x , "" ▁ y ▁ = "" , y ) NEW_LINE","x = 10 y = 5 # Swapping 'x' and 'y' using bitwise XOR operator x = x ^ y y = x ^ y x = x ^ y print(""After swap: x ="", x, "", y ="", y) ",2.080165147781372,0.6907920747410569,0.5655675683627248,0.3545784610270369,0,0.2482049227189258
9291,Java,Python,"import java . io . * ; class GFG { static float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; } static float perimeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; } public static void main ( String [ ] args ) { float r = 10 ; System . out . println ( "" The ▁ Area ▁ of ▁ Semicircle : ▁ "" + area ( r ) ) ; System . out . println ( "" The ▁ Perimeter ▁ of ▁ Semicircle : "" + + perimeter ( r ) ) ; } }","def area ( r ) : NEW_LINE INDENT return ( 0.5 ) * ( 3.14 ) * ( r * r ) NEW_LINE DEDENT def perimeter ( r ) : NEW_LINE INDENT return ( 3.14 ) * ( r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 10 NEW_LINE print ( "" The ▁ Area ▁ of ▁ Semicircle : ▁ "" , area ( r ) ) NEW_LINE print ( "" The ▁ Perimeter ▁ of ▁ Semicircle : ▁ "" , perimeter ( r ) ) NEW_LINE DEDENT","import math class GFG: @staticmethod def area(r): return (0.5 * math.pi * (r ** 2)) @staticmethod def perimeter(r): return (math.pi * r) if __name__ == ""__main__"": r = 10 print(""The Area of Semicircle: "", GFG.area(r)) print(""The Perimeter of Semicircle: "", GFG.perimeter(r)) ",3.464080333709717,0.6035706068803388,0.4755054330046343,0.2726455671344889,0.7499999999999999,0.41585189699414216
12300,Java,Python,"class Test { static int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void main ( String [ ] args ) { int a = 98 , b = 56 ; System . out . println ( "" GCD ▁ of ▁ "" + a + "" ▁ and ▁ "" + b + "" ▁ is ▁ "" + gcd ( a , b ) ) ; } }","def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT","class Test: @staticmethod def gcd(a, b): if a == 0 and b == 0: return 0 if a == 0: return b if b == 0: return a if a == b: return a if a > b: return Test.gcd(a-b, b) return Test.gcd(a, b-a) @staticmethod def main(): a = 98; b = 56 print(""GCD of "" + str(a) + "" and "" + str(b) + "" is "" + str(Test.gcd(a, b))) if __name<｜begin▁of▁sentence｜>__ == '__main__': Test.main() ",5.457535982131958,0.5392980960469639,0.3850085788493866,0.19885452935432887,0.7692307692307692,0.3699674013172609
2311,Java,Python,"class FindFourElements { void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) System . out . print ( A [ i ] + "" ▁ "" + A [ j ] + "" ▁ "" + A [ k ] + "" ▁ "" + A [ l ] ) ; } } } } } public static void main ( String [ ] args ) { FindFourElements findfour = new FindFourElements ( ) ; int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = A . length ; int X = 91 ; findfour . findFourElements ( A , n , X ) ; } }","def findFourElements ( A , n , X ) : NEW_LINE INDENT for i in range ( 0 , n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] + A [ l ] == X : NEW_LINE INDENT print ( "" % d , ▁ % d , ▁ % d , ▁ % d "" % ( A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT A = [ 10 , 2 , 3 , 4 , 5 , 9 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE X = 23 NEW_LINE findFourElements ( A , n , X ) NEW_LINE","class FindFourElements: def find_four_elements(self, A, n, X): for i in range(n - 3): for j in range(i + 1, n - 2): for k in range(j + 1, n - 1): for l in range(k + 1, n): if A[i] + A[j] + A[k] + A[l] == X: print(f""{A[i]} {A[j]} {A[k]} {A[l]}"") if __name__ == ""__main__"": find_four = FindFourElements() A = [10, 20, 30, 40, 1, 2] n = len(A) X = 91 find_four.find_four_elements(A, n, X) ",5.412615776062012,0.7016122902109158,0.6270797536846987,0.5180960761869511,0.888888888888889,0.6293339199975324
836,Java,Python,"class GFG { static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + "" ▁ "" ) ; else System . out . print ( 0 + "" ▁ "" ) ; } System . out . println ( ) ; } return 0 ; } public static void main ( String args [ ] ) { int size = 5 ; identity ( size ) ; } }","def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( ""1 ▁ "" , end = "" ▁ "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ""0 ▁ "" , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT size = 5 NEW_LINE Identity ( size ) NEW_LINE","class GFG: @staticmethod def identity(num): for row in range(num): for col in range(num): if row == col: print(1, end="" "") else: print(0, end="" "") print() if __name__ == ""__main__"": size = 5 GFG.identity(size) ",2.528769016265869,0.4902920853569867,0.367415996993597,0.16251175514422944,0.9090909090909091,0.38648550132823334
7322,Java,Python,"class GFG { static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; { System . out . println ( "" Pattern ▁ found ▁ at ▁ index ▁ "" + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } public static void main ( String [ ] args ) { String txt = "" ABCEABCDABCEABCD "" ; String pat = "" ABCD "" ; search ( pat , txt ) ; } }","def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE print "" Pattern ▁ found ▁ at ▁ index ▁ "" + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT txt = "" ABCEABCDABCEABCD "" NEW_LINE pat = "" ABCD "" NEW_LINE search ( pat , txt ) NEW_LINE","class GFG: @staticmethod def search(pat, txt): M = len(pat) N = len(txt) i = 0 while i <= N - M: j = 0 for j in range(M): if txt[i + j] != pat[j]: break if (j == M-1): print(""Pattern found at index"", i) i = i + M elif j == 0: i = i + 1 else: i = i + j if __name<｜begin▁of▁sentence｜>__ == ""__main__"": txt = "" ABCEABCDABCEABCD "" pat = "" ABCD "" GFG.search(pat, txt) ",4.708270072937012,0.7133984752682031,0.6171517885195759,0.4663733468564765,0.9333333333333333,0.6064613427995336
747,Java,Python,"class GFG { private static void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + "" ▁ "" ) ; printSorted ( arr , start * 2 + 2 , end ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; printSorted ( arr , 0 , arr . length - 1 ) ; } }","def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = "" ▁ "" ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printSorted ( arr , 0 , arr_size - 1 ) NEW_LINE DEDENT","class GFG: @staticmethod def print_sorted(arr, start, end): if start > end: return GFG.print_sorted(arr, start*2+1, end) print(str(arr[start]) + "" ▁ "") GFG.print_sorted(arr, start*2+2, end) def main(args): arr = [4, 2, 5, 1, 3] GFG.print_sorted(arr, 0, len(arr)-1) ",4.117553234100342,0.5962492245487164,0.5181019069917546,0.3900145676241567,0.8571428571428571,0.5301530544797668
13565,Java,Python,"class GFG { static int MAX = 11 ; static boolean isMultipleof5 ( int n ) { char str [ ] = new char [ MAX ] ; int len = str . length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) System . out . println ( n + "" ▁ is ▁ multiple ▁ "" + "" of ▁ 5"" ) ; else System . out . println ( n + "" ▁ is ▁ not ▁ a ▁ "" + "" multiple ▁ of ▁ 5"" ) ; } }","MAX = 11 ; NEW_LINE def isMultipleof5 ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE l = len ( s ) ; NEW_LINE if ( s [ l - 1 ] == '5' or s [ l - 1 ] == '0' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 19 ; NEW_LINE if ( isMultipleof5 ( n ) == True ) : NEW_LINE INDENT print ( n , "" is ▁ multiple ▁ of ▁ 5"" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , "" is ▁ not ▁ a ▁ multiple ▁ of ▁ 5"" ) ; NEW_LINE DEDENT","class GFG: MAX = 11 @staticmethod def isMultipleof5(n): str_ = str(n) if str_[-1] == '5' or str_[-1] == '0': return True else: return False @staticmethod def main(args): n = 19 if GFG.isMultipleof5(n) is True: print(f""{n} is multiple of 5"") else: print(f""{n} is not a multiple of 5"") ",3.0965230464935303,0.5048836489930068,0.3643185202203498,0.19865949721320536,0.9473684210526316,0.42327217436503317
1701,Java,Python,"import java . util . * ; import java . lang . * ; import java . io . * ; class PeakElement { static int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } static int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = arr . length ; System . out . println ( "" Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ "" + findPeak ( arr , n ) ) ; } }","def findPeakUtil ( arr , low , high , n ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] <= arr [ mid ] ) and ( mid == n - 1 or arr [ mid + 1 ] <= arr [ mid ] ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid > 0 and arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return findPeakUtil ( arr , low , ( mid - 1 ) , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return findPeakUtil ( arr , ( mid + 1 ) , high , n ) NEW_LINE DEDENT DEDENT def findPeak ( arr , n ) : NEW_LINE INDENT return findPeakUtil ( arr , 0 , n - 1 , n ) NEW_LINE DEDENT arr = [ 1 , 3 , 20 , 4 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Index ▁ of ▁ a ▁ peak ▁ point ▁ is "" , findPeak ( arr , n ) ) NEW_LINE","def find_peak_util(arr, low, high, n): mid = low + (high - low) // 2 if ((mid == 0 or arr[mid-1] <= arr[mid]) and (mid == n-1 or arr[mid+1] <= arr[mid])): return mid elif (mid > 0 and arr[mid-1] > arr[mid]): return find_peak_util(arr, low, mid - 1, n) else: return find_peak_util(arr, mid + 1, high, n) def find_peak(arr, n): return find_peak_util(arr, 0, n-1, n) arr = [1, 3, 20, 4, 1, 0] n = len(arr) print(""Index of a peak point is "", find_peak(arr, n)) ",6.615487813949585,0.689025327065538,0.6120686584546844,0.4885921838312642,1.0,0.6420145286818849
2147,Java,Python,"import java . io . * ; class GFG { public static void main ( String [ ] args ) { int x = 10 ; int y = 5 ; x = x * y ; y = x / y ; x = x / y ; System . out . println ( "" After ▁ swaping : "" + "" ▁ x ▁ = ▁ "" + x + "" , ▁ y ▁ = ▁ "" + y ) ; } }","x = 10 NEW_LINE y = 5 NEW_LINE x = x * y NEW_LINE y = x // y ; NEW_LINE x = x // y ; NEW_LINE print ( "" After ▁ Swapping : ▁ x ▁ = "" , x , "" ▁ y ▁ = "" , y ) ; NEW_LINE","x = 10 y = 5 x = x * y y = x // y # Using floor division to get integer result of division in Python. In Java we use / for regular division and // for floor division. x = x // y print(""After swaping : "" + "" x = ""+ str(x) +"" , y = ""+str(y)) ",2.1697299480438232,0.4868421052631579,0.38639131151468076,0.22394191063709845,0,0.1567593374459689
3997,Java,Python,"class Main { static void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + "" ▁ - - ▁ "" + next ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = arr . length ; printNSE ( arr , n ) ; } }","def printNSE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + "" ▁ - - ▁ "" + str ( next ) ) NEW_LINE DEDENT DEDENT arr = [ 11 , 13 , 21 , 3 ] NEW_LINE printNSE ( arr ) NEW_LINE","class Main: @staticmethod def printNSE(arr, n): next = None for i in range(n): next = -1 for j in range(i+1, n): if arr[i] > arr[j]: next = arr[j] break print (str(arr[i]) + "" -- "" + str(next)) def main(args): arr = [11, 13, 21, 3] n = len(arr) Main.printNSE(arr, n) Main().main(None) ",3.5076467990875244,0.7036418721611911,0.6083701329041593,0.4723366215452659,0.8,0.5706356350816861
2144,Java,Python,"class GFG { static boolean isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; } public static void main ( String [ ] args ) { int n = 0 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Invalid ▁ number "" ) ; else System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Position ▁ "" + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Invalid ▁ number "" ) ; else System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Position ▁ "" + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Invalid ▁ number "" ) ; else System . out . println ( "" n ▁ = ▁ "" + n + "" , ▁ Position ▁ "" + pos ) ; } }","def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if not isPowerOfTwo ( n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 0 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" Invalid ▁ number "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" Position "" , pos ) NEW_LINE DEDENT n = 12 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" Invalid ▁ number "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" Position "" , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" Invalid ▁ number "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" n ▁ = "" , n , "" Position "" , pos ) NEW_LINE DEDENT DEDENT","class GFG: @staticmethod def isPowerOfTwo(n): return n > 0 and ((n & (n - 1)) == 0) @staticmethod def findPosition(n): if not GFG.isPowerOfTwo(n): return -1 count = 0 while n > 0: n = n >> 1 count += 1 return count if __name__ == ""__main__"": n = 0 pos = GFG.findPosition(n) if pos == -1: print(""n = "", n, "", Invalid number"") else: print(""n = "", n, "", Position = "", pos) n = 12 pos = GFG.findPosition(n) if pos == -1: print(""n = "", n, "", Invalid number"") else: print(""n = "", n, "", Position = "", pos) n = 128 pos = GFG.findPosition(n) if pos == -1: print(""n = "", n, "", Invalid number"") else: print(""n = "", n, "", Position = "", pos) ",9.484126091003418,0.6617334235987361,0.5332665713454138,0.33772991189006707,0.9333333333333333,0.5164109383230469
9367,Java,Python,"import java . io . * ; class GFG { static void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; System . out . print ( "" x3 ▁ = ▁ "" + x3 + "" ▁ "" ) ; System . out . print ( "" y3 ▁ = ▁ "" + y3 + "" ▁ "" ) ; System . out . print ( "" z3 ▁ = ▁ "" + z3 + "" ▁ "" ) ; } public static void main ( String [ ] args ) { int a = 1 ; int b = - 2 ; int c = 0 ; int d = 0 ; int x1 = - 1 ; int y1 = 3 ; int z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; } }","def mirror_point ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( ( a * a + b * b + c * c ) ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE x3 = 2 * x2 - x1 NEW_LINE y3 = 2 * y2 - y1 NEW_LINE z3 = 2 * z2 - z1 NEW_LINE print "" x3 ▁ = "" , x3 , NEW_LINE print "" y3 ▁ = "" , y3 , NEW_LINE print "" z3 ▁ = "" , z3 , NEW_LINE DEDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE mirror_point ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE","class GFG: @staticmethod def mirror_point(a, b, c, d, x1, y1, z1): k = (-a * x1 - b * y1 - c * z1 - d) / (float)(a * a + b * b + c * c) x2 = a * k + x1 y2 = b * k + y1 z2 = c * k + z1 x3 = 2 * x2 - x1 y3 = 2 * y2 - y1 z3 = 2 * z2 - z1 print(""x3 ⁻¹="", ""⁻¹ "", x3) print(""y3 ⁻¹="", ""⁻¹ "", y3) print(""z3 ⁻¹="", ""⁻¹ "", z3) GFG.mirror_point(1, -2, 0, 0, -1, 3, 4) ",7.456660985946655,0.6875754584126489,0.5774683082242114,0.4586127819396291,0.6666666666666666,0.5210289473577403
